#!/bin/bash
#mlx.bsh
#license: LGPLv2.1
#functions and variables for running MeshLab and mlx scripts
# filters are based on MeshLab v 1.3.4BETA for 64 bit Windows

##Set program locations, ML_VERSION, aliases##
if [[ $(uname -s) == CYGWIN* ]]; then
    _CYGBIN="C:\cygwin64\bin" # Cygwin bin directory location
    
    ML_VERSION="1.3.4BETA" # MeshLab version, 1.3.3 or 1.3.4BETA or SVN
    
	# Set paths for dependencies
	MESHLAB_PATH="/cygdrive/c/Program Files/VCG/MeshLab"
	OPENSCAD_PATH="/cygdrive/c/Program Files/OpenSCAD"
	ADMESH_PATH="/cygdrive/c/Program Files/admesh"
	#INKSCAPE_PATH="/cygdrive/c/Program Files/Inkscape"
    
	alias openscad="openscad.com"
	#alias inkscape="inkscape.com"
	
    #to copy & paste into cygwin session for interactive use
    # PATH="/cygdrive/c/Program Files/VCG/MeshLab":"/cygdrive/c/Program Files/OpenSCAD":"/cygdrive/c/Program Files/Inkscape":"/cygdrive/c/Program Files/admesh":$PATH 
	PATH=$MESHLAB_PATH:$OPENSCAD_PATH:$ADMESH_PATH:$PATH #:$INKSCAPE_PATH
elif [[ $(uname -s) == Linux* ]]; then
    ML_VERSION="1.3.3" # MeshLab version, 1.3.3 or 1.3.4BETA or SVN
#elif [ "$(uname)" == "Darwin" ]; then
    # Do something under Mac OS X platform
fi

# REF: test if empty or not:
# -z true if string is zero
# -n true if string is non-zero
# -e true if file exists
# -s true if file exists and size is greater than zero

# TODO: identify which filters cause a new layer to be created and what the new layer label is

# TODO: add some error checking of input

# TODO: write script to split model into individual parts
# could use sel_small_parts with .99, then invert select to delete the largest object, & iterate.
# 1-delete small parts to get largest volume; save
# 2-select small parts, invert sel & del largest part. Go to 1.

if [ -z "${scriptpath}" ]; then
    scriptpath="$(cd "$(dirname "$0")"; pwd -P)"
fi

. ${scriptpath}/measure.bsh

###Initialize variables for run_meshlab
ml_IF="" #input filename
ml_OF="" #output filename
ml_SF="" #filename for .mlx filter script
ml_LF="" #filename for ML log
run_meshlab() {
    ##Function to run meshlabserver
    ##Variables (set before calling):
    # ml_IF
    # ml_OF
    # ml_SF (run mlx script, not needed e.g. just to convert formats)
    # ml_LF (save a log file, mostly useful for cgm & ctm)
    # om overwrite default om values
    # m_color (for do_om, only needed if ml_OF is not "empty")
    
    # TODO: add support for meshlab project files
    # TODO: add support for multiple input files
    
    local start_time
    local end_time
    local diff_time
    local return_code
    local S
    local L
    local O
    #local om # can set this in calling function to manually override
  
    #set -x
    if [ -z "$ml_SF" ]; then
        S=""
    else
        S="-s $ml_SF"
    fi

    if [ -z "$ml_LF" ]; then
        L=""
    else
        rm -f "$ml_LF" # Remove any existing log file before we write to it
        L="-l $ml_LF"
    fi
    
    if [ -z "$ml_OF" ]; then
        O=""
        om=""
    else
        O="-o $ml_OF"
        if [ -z "$om" ]; then
            #if [ -z "$m_color" ]; then
            #    do_subfiles "$ml_IF"
            #fi
            do_om "$@" # set om options based on output extension and m_color
        fi
    fi
    
	echo
	if [ "$verbosity" -ge 5 ]; then
		echo "*MeshLab*MeshLab*MeshLab*MeshLab*MeshLab*MeshLab*MeshLab*MeshLab*"
	fi
    echo -n "    Running MeshLab ... "
    start_time=$(date +%s.%N)
    silent meshlabserver $L -i "$ml_IF" $O $om $S  # Note: no quotes around options, $L must go first
    return_code=$?
    end_time=$(date +%s.%N)
    diff_time=$(bc <<< "$end_time - $start_time")
    diff_time=$(printf %.0f $diff_time) #round to integer milliseconds
    #echo -n "finished in "; printf "%.2fs\n" $diff_time
    echo -n "finished in "; printf "%0dh:%0dm:%0ds" $(($diff_time/3600)) $(($diff_time%3600/60)) $(($diff_time%60)); echo ", return code: $return_code"
	if [  "$verbosity" -ge 5 ]; then
		echo "*MeshLab*MeshLab*MeshLab*MeshLab*MeshLab*MeshLab*MeshLab*MeshLab*"
	fi
    if [ $return_code -ne 0 ]; then
        pause "Uh oh, looks like there's an error. Hit any key to keep going anyway ... "
    fi
    
    ml_SF=""

    return $return_code
}

# NOTE: this function isn't related to MeshLab in any way, however it is here due to its high degree of similarity with run_meshlab, which makes maintenance easier
run_openscad() {
    #$1=input
    #$2=output
	
	#set -x
    local start_time
    local end_time
    local diff_time
    local return_code
    
    echo ; echo -n "Rendering OpenSCAD file & generating stl ... "
    start_time=$(date +%s.%N)
    openscad -o "$2" "$1"
    return_code=$?
    end_time=$(date +%s.%N)
    diff_time=$(bc <<< "$end_time - $start_time")
    diff_time=$(printf %.0f $diff_time) #round to integer milliseconds
    echo -n "finished in "; printf "%0dh:%0dm:%0ds" $(($diff_time/3600)) $(($diff_time%3600/60)) $(($diff_time%60)); echo ", return code: $return_code"
    
    if [ $return_code -ne 0 ]; then
        pause "Uh oh, looks like there's an error. Hit any key to keep going anyway ... "
    fi
        
    return $return_code
}

run_admesh() {
    #$1=input
    #$2=output - if blank run check only, otherwise output ascii stl
    
    local start_time
    local end_time
    local diff_time
    local return_code
    local O=""
    
    # set default log file if it is not already set
    if [ -z "$admesh_LF" ]; then
        admesh_LF="TEMP3DL_admeshlog.txt"
    fi
    
    # check for output file
    if [ -n "$2" ]; then
        O="-a $2"
    fi
    
	echo
	if [  "$verbosity" -ge 4  ]; then
		echo "*ADMesh*ADMesh*ADMesh*ADMesh*ADMesh*ADMesh*ADMesh*ADMesh*ADMesh*"
	fi
    echo -n "    Running ADMesh ... "
    start_time=$(date +%s.%N)
    admesh "$1" $O > "$admesh_LF"
    return_code=$?
    end_time=$(date +%s.%N)
    diff_time=$(bc <<< "$end_time - $start_time")
    diff_time=$(printf %.0f $diff_time) #round to integer milliseconds
    echo -n "finished in "; printf "%0dh:%0dm:%0ds" $(($diff_time/3600)) $(($diff_time%3600/60)) $(($diff_time%60)); echo ", return code: $return_code"
    if [ "$verbosity" -ge 4 ]; then
		echo "*ADMesh*ADMesh*ADMesh*ADMesh*ADMesh*ADMesh*ADMesh*ADMesh*ADMesh*"
	fi
    if [ $return_code -ne 0 ]; then
        pause "Uh oh, looks like there's an error. Hit any key to keep going anyway ... "
    fi
    
    return $return_code
}

# Modify this function to add additional input file support
# Function to find associated subfiles, e.g. material & texture files.
do_subfiles () {
    
    # Add additional file type support in the future, e.g. ply

    case "${1##*.}" in # check file extension of input
        [Oo][Bb][Jj] )
            # Texture Format: mtllib ./model_mesh.obj.mtl
            material_file=$(grep "mtllib" "$1" 2> /dev/null | cut -d" " -f2)
            material_file="${material_file##*/}" # strip out path
            # Vector colors: "v" entries have 6 values instead of just 3 (last 3 are r g b)
    
            if [ -n "$material_file" ]; then
                # Texture Format: map_Kd model_texture.jpg
                # texture_files: array of texture image files
                OIFS="$IFS"; IFS=$'\n'; texture_files=( $(grep "map_Kd" "$material_file" | cut -d" " -f2) ); IFS="$OIFS"
                OIFS="$IFS"; IFS=$'\n'; texture_files_unique=( $(sort -u <<< "${texture_files[*]}") ); IFS="$OIFS"
            fi
    
            if [ "$verbosity" -ge 2 ]; then
                echo
                echo "Material file: ""$material_file"
                echo "Number of texture file(s): " ${#texture_files[@]}
                echo "Number of unique texture file(s): " ${#texture_files_unique[@]}
                echo "Texture file(s): " ${texture_files[@]}
                echo "Unique Texture file(s): " ${texture_files_unique[@]}
            fi
            ;;
        [Ss][Tt][Ll] )
            texture_files=()
            ;;
        [wW][rR[lL] ) # VRML V2.0 NOT TESTED
            # Texture Format: texture ImageTexture { url "model_texture.jpg" }
            OIFS="$IFS"; IFS=$'\n'; texture_files=( $(grep "ImageTexture" "$1" | cut -d"\"" -f2) ); IFS="$OIFS"
            OIFS="$IFS"; IFS=$'\n'; texture_files_unique=( $(sort -u <<< "${texture_files[*]}") ); IFS="$OIFS"
            if [ "$verbosity" -ge 2 ]; then
                echo
                echo "Number of texture file(s): " ${#texture_files[@]}
                echo "Number of unique texture file(s): " ${#texture_files_unique[@]}
                echo "Texture file(s): " ${texture_files[@]}
                echo "Unique Texture file(s): " ${texture_files_unique[@]}
            fi
            ;;
        [Xx]3[Dd] )
            # Texture Format: <ImageTexture url="model_texture.jpg"/>
            OIFS="$IFS"; IFS=$'\n'; texture_files=( $(grep "ImageTexture" "$1" | cut -d"\"" -f2) ); IFS="$OIFS"
            OIFS="$IFS"; IFS=$'\n'; texture_files_unique=( $(sort -u <<< "${texture_files[*]}") ); IFS="$OIFS"
            if [ "$verbosity" -ge 2 ]; then
                echo
                echo "Number of texture file(s): " ${#texture_files[@]}
                echo "Number of unique texture file(s): " ${#texture_files_unique[@]}
                echo "Texture file(s): " ${texture_files[@]}
                echo "Unique Texture file(s): " ${texture_files_unique[@]}
            fi
            ;;
        [Dd][Aa][Ee] ) # COLLADA
            # Texture Format:   <image id="texture0" name="texture0">
            #               <init_from>model_texture.jpg</init_from>
            #           </image>
            OIFS="$IFS"; IFS=$'\n'; texture_files=( $(xmlstarlet sel -N x=http://www.collada.org/2005/11/COLLADASchema -t -v "x:COLLADA/x:library_images/x:image/x:init_from" "$1") ); IFS="$OIFS"
            OIFS="$IFS"; IFS=$'\n'; texture_files_unique=( $(sort -u <<< "${texture_files[*]}") ); IFS="$OIFS"
            if [ "$verbosity" -ge 2 ]; then
                echo
                echo "Number of texture file(s): " ${#texture_files[@]}
                echo "Number of unique texture file(s): " ${#texture_files_unique[@]}
                echo "Texture file(s): " ${texture_files[@]}
                echo "Unique Texture file(s): " ${texture_files_unique[@]}
            fi
            ;;
        [pP][lL][yY] ) # Can read binary files too; the header is in ascii
            # Texture Format: comment TextureFile model_texture.jpg
            # This works for MeshLab & itSeez3D, but may not work for every ply file. Can't get textured models to work in blender yet.
            OIFS="$IFS"; IFS=$'\n'; texture_files=( $(grep -a "TextureFile" "$1" | cut -d" " -f3) ); IFS="$OIFS"
            OIFS="$IFS"; IFS=$'\n'; texture_files_unique=( $(sort -u <<< "${texture_files[*]}") ); IFS="$OIFS"
            if [ "$verbosity" -ge 2 ]; then
                echo
                echo "Number of texture file(s): " ${#texture_files[@]}
                echo "Number of unique texture file(s): " ${#texture_files_unique[@]}
                echo "Texture file(s): " ${texture_files[@]}
                echo "Unique Texture file(s): " ${texture_files_unique[@]}
            fi
            ;;
        * )
            echo "${1##*.} is not currently supported"
            texture_files=()
            return 1
        ;;
    esac
    
    ## Vertex colors could be added in the future
    if [ ${#texture_files_unique[@]} -ne 0 ]; then
        m_color="UV"
        color_UV="true"
    else
        m_color="NC"
        color_UV="false"
    fi
    
    if [ ${#texture_files[@]} -gt 1 ]; then
        echo ; echo "WARNING: model has ${#texture_files_unique[@]} unique texture files and ${#texture_files[@]} total texture files!"
    fi
    
    return 0
}

#Modify this to add more output file types
do_om () {
    # Function to set MeshLab output mask -m options
    # Usage: the file extension as input to this program
    # TODO: Add additional file type support in the future, e.g. ply
    # TODO: does it do any harm to define vc even if there are none?

    # MeshLab output mask (-m) options:
    # Note: v1.34BETA changed -om switch to -m
    # vc -> vertex colors
    # vf -> vertex flags
    # vq -> vertex quality
    # vn-> vertex normals
    # vt -> vertex texture coords
    # fc -> face colors
    # ff -> face flags
    # fq -> face quality
    # fn-> face normals
    # wc -> wedge colors
    # wn-> wedge normals
    # wt -> wedge texture coords

    if [[ "$ML_VERSION" < "1.3.4" ]]; then
        om_flag="-om"
    else
        om_flag="-m"
    fi
    
    case "${ml_OF##*.}" in
        [Oo][Bb][Jj] )
            if [ "$m_color" = "UV" ] || [ "$color_UV" = "true" ]; then
                om="$om_flag vc vn fc wt" # colored texture
            else
                om="$om_flag vc vn" # VC by default. Note that if there are no VC it will assign "white" to every vertex
            fi
            ;;
        [Ss][Tt][Ll] | [Xx][Yy][Zz] | [Dd][Xx][Ff] )
            om="" # no colors or other options; will be exported as binary
            ;;
        [Pp][Ll][Yy] ) #TODO: check this! Available options: vf, vc, vn, ff
            if [ "$m_color" = "UV" ] || [ "$color_UV" = "true" ]; then
                om="$om_flag vc vn wt" # textured ply; will be exported as binary
            else
                om="$om_flag vc vn" 
            fi
            ;;
        [Xx]3[Dd] )
            om="$om_flag vc vn wt" # textured x3d
            ;;
        [Dd][Aa][Ee] ) # COLLADA
            om="$om_flag vc vn wt" # textured COLLADA (dae)
            ;;
        * )
            echo "$1 is not currently supported, exiting..."
            exit 1
            ;;
    esac
    
    for i in "$@"; do # TODO: need to test!
        case $i in
            +*) # add om option
                om="${om} ${i#*+}"
                axis=0 # X axis
                offset="${i#*=}"
                shift # past argument=value
                ;;
            -*) # remove om option
                om=${om/?${i#*-}/}
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done
    return 0
}

# ml_IF must be set before calling this
mlx_begin() {
    if [ -z "$ml_SF" ]; then
        ml_SF="TEMP3DL_default.mlx" # set a default script filename if none is already set
    fi

    echo "<!DOCTYPE FilterScript>
<FilterScript>" > "$ml_SF"
    if [ -z "$ml_IF" ]; then
        # If input file is blank, create a dummy input file then delete it as the first step
        echo "0 0 0" > TEMP3DL.xyz
        ml_IF="TEMP3DL.xyz"
        mlx_del_layer
    else
        case "${ml_IF##*.}" in # check file extension of input
            [Ss][Tt][Ll] )
                mlx_merge_V # Same as "Unify Duplicated Vertices" in MeshLab stl import
                ;;
        esac
    fi
}

mlx_end() {
    echo "</FilterScript>" >> "$ml_SF"
}

#example usage
#    mlx_begin
#    mlx_scale scale=.5
#    mlx_end


### Begin Measure ###

mlx_measure_geometry () {
    echo "    <xmlfilter name=\"Compute Geometric Measures\"/>" >> "$ml_SF"
}

mlx_measure_topology() {
    echo "    <xmlfilter name=\"Compute Topological Measures\"/>" >> "$ml_SF"
}

# Usage: parse_geometry_log "$ml_LF"
parse_geometry_log() {
    local line_no
    
    # TODO: if mesh is non-manifold many of these are undefined. Need to add checks to see if these are actually returning numbers. If not, set as "NAN"?
    
    # xsize=$(grep "Mesh Bounding Box Size" "$1" | cut -d" " -f5)
    # ysize=$(grep "Mesh Bounding Box Size" "$1" | cut -d" " -f6)
    # zsize=$(grep "Mesh Bounding Box Size" "$1" | cut -d" " -f7)
    volume_mm3=$(grep -m1 "Mesh Volume" "$1" | tr -s " " | cut -d" " -f4)
    volume_cm3=$(bc <<< "scale=10;($volume_mm3 * 0.001)")
    
    area_mm2=$(grep -m1 "Mesh Surface" "$1" | tr -s " " | cut -d" " -f4)
    area_cm2=$(bc <<< "scale=10;($area_mm2 * 0.01)")
    
    total_E_length=$(grep -m1 "Mesh Total Len of" "$1" | tr -s " " | cut -d" " -f8)
    
    total_fauxE_length=$(grep -m2 "Mesh Total Len of" "$1" | tr -s " " | cut -d" " -f8)
    
    barycenter=( $(grep -m1 "Thin shell barycenter" "$1" | tr -s " " | cut -d" " -f4-6) )
    
    center_of_mass=( $(grep -m1 "Center of Mass" "$1" | tr -s " " | cut -d" " -f5-7) )
    
    line_no=$(grep -n -m1 "Inertia Tensor" "$1" | cut -d":" -f1)
    inertia_tensor_R0C=( $(awk NR==$((line_no+1)) "$1" | tr -s " " | cut -d" " -f3-5) )
    inertia_tensor_R1C=( $(awk NR==$((line_no+2)) "$1" | tr -s " " | cut -d" " -f3-5) )
    inertia_tensor_R2C=( $(awk NR==$((line_no+3)) "$1" | tr -s " " | cut -d" " -f3-5) )
    
    line_no=$(grep -n -m1 "Principal axes" "$1" | cut -d":" -f1)
    principal_axes_R0C=( $(awk NR==$((line_no+1)) "$1" | tr -s " " | cut -d" " -f3-5) )
    principal_axes_R1C=( $(awk NR==$((line_no+2)) "$1" | tr -s " " | cut -d" " -f3-5) )
    principal_axes_R2C=( $(awk NR==$((line_no+3)) "$1" | tr -s " " | cut -d" " -f3-5) )
    
    line_no=$(grep -n -m1 "axis momenta" "$1" | cut -d":" -f1)
    axis_momenta=( $(awk NR==$((line_no+1)) "$1" | tr -s " " | cut -d" " -f3-5) )
    
    if [ "$verbosity" -ge 2 ]; then
        printf "\n***Parsed Geometry Values***\n"
        printf "  Volume (cm^3): %.2f\n" "$volume_cm3"
        printf "  Surface Area (cm^2): %.2f\n" "$area_cm2"
        printf "  Total Edge Length (mm): %.2f\n" "$total_E_length"
        printf "  Thin shell barycenter: ( %.2f %.2f %.2f )\n" ${barycenter[@]}
        printf "  Center of Mass: ( %.2f %.2f %.2f )\n" ${center_of_mass[@]}
        printf "  Inertia Tensor: ( %.2f %.2f %.2f )\n" ${inertia_tensor_R0C[@]}
        printf "                  ( %.2f %.2f %.2f )\n" ${inertia_tensor_R1C[@]}
        printf "                  ( %.2f %.2f %.2f )\n" ${inertia_tensor_R2C[@]}
        printf "  Principal axes: ( %.2f %.2f %.2f )\n" ${principal_axes_R0C[@]}
        printf "                  ( %.2f %.2f %.2f )\n" ${principal_axes_R1C[@]}
        printf "                  ( %.2f %.2f %.2f )\n" ${principal_axes_R2C[@]}
        printf "  Axis momenta: ( %.2f %.2f %.2f )\n" ${axis_momenta[@]}
        printf "***Parsed Geometry Values***\n"
    fi
    return 0
}

# Usage: parse_topology_log "$ml_LF"
parse_topology_log() {
    local line_no
    
    num_geometry=$(grep -m1 "V: " "$1")
    num_gemoetry="${num_geometry// /}" # strip all whitespace
    #echo num_gemoetry = "$num_gemoetry"
    num_V=$(echo "$num_gemoetry" | cut -d":" -f2)
    num_V="${num_V%?}" # strip last character
    num_E=$(echo "$num_gemoetry" | cut -d":" -f3)
    num_E="${num_E%?}" # strip last character
    num_F=$(echo "$num_gemoetry" | cut -d":" -f4)

    num_unref_V=$(grep -m1 "Unreferenced Vertices " "$1" | cut -d" " -f3)
    # Filters | Cleaning & Repairing | Remove Unreferenced Vertex
    num_boundry_E=$(grep -m1 "Boundary Edges " "$1" | cut -d" " -f3)
    num_parts=$(grep -m1 "Mesh is composed by " "$1" | cut -d" " -f5)

    manifold=$(grep -m1 "manifold" "$1" | cut -d" " -f3) # two-manifold or non-manifold
    #Mesh is two-manifold 
    #Mesh has 5 non two manifold edges and 20 faces are incident on these edges
    # Filters | Cleaning & Repairing | Remove Faces from Non Manifold Edges
    # number or "two-manifold"
    if [ "$manifold" = "two-manifold" ]; then
        manifold="2-manifold"
        non_manifold_E="0"
        non_manifold_V="0"
    else
        isnumber "$manifold"
        if [ $? -eq 0 ] ; then
            non_manifold_E=$(grep -m1 "non two manifold edges" "$1" | cut -d" " -f3)
            non_manifold_V=$(grep -m1 "non two manifold vertexes" "$1" | cut -d" " -f3)
        else
            echo "What's going on here?"
        fi
        manifold="non-manifold"
    fi
    
    # Piping through tail -1 finds the LAST occurrence
    if [ "$manifold" = "2-manifold" ]; then
        num_holes=$(grep " holes" "$1" | tail -1 | cut -d" " -f3) # number of holes
        #Mesh has a undefined number of holes (non 2-manifold mesh)
        # number or "a"
        genus=$(grep -m1 "Genus is " "$1" | tail -1 | cut -d" " -f3) # mesh genus, i.e. how many "handles"
        #Genus is undefined (non 2-manifold mesh)
    else
        num_holes="undefined (non-manifold)"
        genus="undefined (non-manifold)"
    fi
  
    if [ "$verbosity" -ge 5 ]; then
        echo ; echo "***MeshLab Compute Topological Measures Results***"
        line_no=$(grep -n -m1 "V: " "$1" | cut -d":" -f1)
        tail -n +$line_no "$1"
        echo "***MeshLab Compute Topological Measures Results***"
    fi
    if [ "$verbosity" -ge 2 ]; then
        echo ; echo "***Parsed Topology Values***"
        echo "  Vertices: $num_V"
        echo "  Edges: $num_E"
        echo "  Faces: $num_F"
        echo
        echo "  Parts (Components): $num_parts"
        echo "  $manifold"
        echo "    Non 2-manifold Edges: $non_manifold_E"
        echo "    Non 2-manifold Vertices: $non_manifold_V"
        echo "    Holes: $num_holes"
        echo "    Boundary (Hole) Edges: $num_boundry_E"
        echo "    Genus: $genus"
        echo "  Unreferenced Vertices: ""$num_unref_V"
        echo "***Parsed Topology Values***"
    fi
    return 0
}

# Usage: mlx_section X=|Y=|(Z=0)|custom= surface=(false) customaxis=x,y,z planeref=(2)
# TIP: surfaces can also be simplified after generation
# Recommended extensions:
# surface: stl, obj
# line: dxf, obj (need to process obj)
# points: xyz (for measuring size)
mlx_section() {
    # Options & Defaults
    local axis=2 # The slicing plane is perpendicular to this axis (default Z)
    local offset=0 # cross-plane offset
    local surface="false" # false (default) will create a 2D surface, otherwise will create a 1D outline composed of line segments (not a continuous polyline but individual segments)
    local customAxis=( 0 0 1 ) # custom axis (vector)
    local planeref=2  #the reference from which the planes are shifted; 0=BB Center, 1=BB Min, 2=Origin
    
    # Other
    local i
    local j
    
    for i in "$@"; do
        case $i in
            [xX]=*)
                axis=0 # X axis
                offset="${i#*=}"
                shift # past argument=value
                ;;
            [yY]=*)
                axis=1 # Y axis
                offset="${i#*=}"
                shift # past argument=value
                ;;
            [zZ]=*)
                axis=2 # Z axis
                offset="${i#*=}"
                shift # past argument=value
                ;;
            custom=*)
                axis=3 # Custom axis
                offset="${i#*=}"
                shift # past argument=value
                ;;
            surface=*)
                surface="${i#*=}"
                shift # past argument=value
                ;;
            custom[aA]xis=*)
                OIFS="$IFS"; IFS=,; read -a customAxis <<< "${i#*=}"; IFS="$OIFS"
                for ((j=0; j<${#customAxis[@]}; j++)); do
                    if [ -z ${customAxis[$j]} ]; then customAxis[$j]=0; fi
                    #echo "end j=\"${customAxis[$j]}\""
                done
                if [ ${#customAxis[@]} -eq 2 ]; then customAxis[2]=0; fi # sets z axis to 0 if left blank
                #echo "customAxis = ( ${customAxis[@]} )"
                shift # past argument=value
                ;;
            planeref=*)
                planeref="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done
    
    if [ "$axis" -eq 3 ] && [[ " ${customAxis[@]} " = " 0 0 1 " ]]; then
        echo ; echo "WARNING: a custom axis was selected, however \"customAxis=\" was not provided. Using default (Z) instead."
    fi
    
    echo "\
    <filter name=\"Compute Planar Section\">
        <Param name=\"planeAxis\" description=\"Plane perpendicular to\" value=\"$axis\" enum_val0=\"X Axis\" enum_val1=\"Y Axis\" enum_val2=\"Z Axis\" enum_val3=\"Custom Axis\" enum_cardinality=\"4\" type=\"RichEnum\" tooltip=\"The Slicing plane will be done perpendicular to the axis\"/>
        <Param name=\"customAxis\" description=\"Custom axis\" x=\"${customAxis[0]}\" y=\"${customAxis[1]}\" z=\"${customAxis[2]}\" type=\"RichPoint3f\" tooltip=\"Specify a custom axis, this is only valid if the above parameter is set to Custom\"/>
        <Param name=\"planeOffset\" description=\"Cross plane offset\" value=\"$offset\" type=\"RichFloat\" tooltip=\"Specify an offset of the cross-plane. The offset corresponds to the distance from the point specified in the plane reference parameter. By default (Cross plane offset == 0)\"/>
        <Param name=\"relativeTo\" description=\"plane reference\" value=\"$planeref\" enum_val0=\"Bounding box center\" enum_val1=\"Bounding box min\" enum_val2=\"Origin\" enum_cardinality=\"3\" type=\"RichEnum\" tooltip=\"Specify the reference from which the planes are shifted\"/>
        <Param name=\"createSectionSurface\" description=\"Create also section surface\" value=\"$surface\" type=\"RichBool\" tooltip=\"If selected, in addition to a layer with the section polyline, it will be created also a layer with a triangulated version of the section polyline. This only works if the section polyline is closed\"/>
    </filter>" >> "$ml_SF"
}

### End Measure ###


### Begin Cleaning & Repair ###
# (Also see Selection & Deletion section for lots of cleaning functions)

# Usage: mlx_merge_V threshold=(0)
mlx_merge_V () {
    # Options & Defaults
    local threshold=0
    
    # Other
    local i
    
    for i in "$@"; do
        case $i in
            t=*|threshold=*)
                threshold="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done

    echo "\
    <filter name=\"Merge Close Vertices\">
        <Param name=\"Threshold\" description=\"Merging distance\" value=\"$threshold\"  min=\"0\" max=\"1\" type=\"RichAbsPerc\" tooltip=\"All the vertices that closer than this threshold are merged together. Use very small values, default values is 1/10000 of bounding box diagonal.\"/>
    </filter>" >> "$ml_SF"
}

# Usage: mlx_close_holes maxholesize=(30)
# TIP: run subdivide on the slected faces next if the hole is large
# TODO: automatically subdivide based on how many edges are in hole. 
# Need to experiment to find good numbers.
# Run filter with progressivley larger hole sizes, subdiving by increasing amounts as hole gets bigger
mlx_close_holes() {
    # Options & Defaults
    local maxholesize=30 # Max hole size to be closed, as expressed as number of edges composing the hole boundary (default 30)
    local selected="false" # Only the holes with at least one of the boundary faces selected are closed
    local selnewF="true" # After closing a hole the faces that have been created are left selected. Any previous selection is lost. Useful for example for smoothing the newly created holes.
    local selfintersection="true" # When closing holes it tries to prevent the creation of faces that intersect faces adjacent to the boundary of the hole. 
    
    # Other
    local i
    
    for i in "$@"; do
        case $i in
            max=*|maxholesize=*)
                maxholesize="${i#*=}"
                shift # past argument=value
                ;;
            sel=*|selected=*)
                selected="${i#*=}"
                shift # past argument=value
                ;;
            selnew[fF]=*)
                selnewF="${i#*=}"
                shift # past argument=value
                ;;
            selfintersection=*)
                selfintersection="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done
    
    echo "\
    <filter name=\"Close Holes\">
        <Param name=\"maxholesize\" description=\"Max size to be closed \" value=\"$maxholesize\" type=\"RichInt\" tooltip=\"The size is expressed as number of edges composing the hole boundary\"/>
        <Param name=\"Selected\" description=\"Close holes with selected faces\" value=\"$selected\" type=\"RichBool\" tooltip=\"Only the holes with at least one of the boundary faces selected are closed\"/>
        <Param name=\"NewFaceSelected\" description=\"Select the newly created faces\" value=\"$selnewF\" type=\"RichBool\" tooltip=\"After closing a hole the faces that have been created are left selected. Any previous selection is lost. Useful for example for smoothing the newly created holes.\"/>
        <Param name=\"SelfIntersection\" description=\"Prevent creation of selfIntersecting faces\" value=\"$selfintersection\" type=\"RichBool\" tooltip=\"When closing an holes it tries to prevent the creation of faces that intersect faces adjacent to the boundary of the hole. It is an heuristic, non intersecting hole filling can be NP-complete.\"/>
    </filter>" >> "$ml_SF"
}

# Usage: mlx_grow_holes iterations=(3)
mlx_grow_holes() {
    # Options & Defaults
    local iterations=3 # Number of times to grow holes
    
    # Other
    local i
    
    for i in "$@"; do
        case $i in
            [iI]=*|[iI]terations=*)
                iterations="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done
   
    mlx_sel_border
    mlx_grow_sel iterations="$iterations"
    mlx_del_sel_V_F
    mlx_del_unreferenced_V
}

mlx_reorient_normals() {
    echo "    <filter name=\"Re-Orient all faces coherentely\"/>" >> "$ml_SF"
}

mlx_flip_normals() {
    # Options & Defaults
    local forceFlip="false" # If true, the normals will always be flipped; otherwise, the filter tries to set them outside
    local selected="false" # If true the filter affects only the selected faces.
    
    # Other
    local i
    
    for i in "$@"; do
        case $i in
            force[fF]lip=*|[fF][fF]=*)
                forceFlip="${i#*=}"
                shift # past argument=value
                ;;
            sel=*|selected=*)
                selected="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done
    
    if [ -z "$mlx_flip_normals_forceFlip" ]; then mlx_flip_normals_forceFlip="true"; fi
    if [ -z "$mlx_flip_normals_Selected" ]; then mlx_flip_normals_Selected="false"; fi
    
    echo "\
    <filter name=\"Invert Faces Orientation\">
        <Param name=\"forceFlip\" description=\"Force Flip\" value=\"$forceFlip\" type=\"RichBool\" tooltip=\"If selected, the normals will always be flipped; otherwise, the filter tries to set them outside\"/>
        <Param name=\"onlySelected\" description=\"Flip only selected faces\" value=\"$selected\" type=\"RichBool\" tooltip=\"If selected, only selected faces will be affected\"/>
    </filter>" >> "$ml_SF"
}

# Will reorient normals & then make sure they are oriented outside
mlx_fix_normals() {
    mlx_reorient_normals
    mlx_flip_normals
}

mlx_split_V_on_nonmanifold_F() {
    # Options & Defaults
    local VDispRatio=0 # When a vertex is split it is moved along the average vector going from its position to the baricyenter of the FF connected faces sharing it
    
    # Other
    local i
    
    for i in "$@"; do
        case $i in
            [vV][dD]isp[rR]atio=*|[vV][dD][rR]=*)
                VDispRatio="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done
    
    echo "\
    <filter name=\"Split Vertexes Incident on Non Manifold Faces\">
        <Param name=\"VertDispRatio\" description=\"Vertex Displacement Ratio\" value=\"$VDispRatio\" type=\"RichFloat\" tooltip=\"When a vertex is split it is moved along the average vector going from its position to the baricyenter of the FF connected faces sharing it\"/>
    </filter>" >> "$ml_SF"
}

# TODO: need to test
mlx_fix_folded_F() {
    echo "    <filter name=\"Remove Isolated Folded Faces by Edge Flip\"/>" >> "$ml_SF"
}

mlx_snap_mismatched_borders() {
    # Options & Defaults
    local E_distRatio="0.01" # Collapse edge when the edge / distance ratio is greater than this value. E.g. for default value 1/1000 two straight border edges are collapsed if the central vertex dist from the straight line composed by the two edges less than a 1/1000 of the sum of the edges length. Larger values enforce that only vertexes very close to the line are removed.
    local unify_V="true" # If true the snap vertices are welded together.
    
    # Other
    local i
    
    for i in "$@"; do
        case $i in
            E_dist[rR]atio=*)
                E_distRatio="${i#*=}"
                shift # past argument=value
                ;;
            unify_V=*)
                unify_V="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done
    
    echo "\
    <filter name=\"Snap Mismatched Borders\">
        <Param name=\"EdgeDistRatio\" description=\"Edge Distance Ratio\" value=\"$E_distRatio\" type=\"RichFloat\" tooltip=\"Collapse edge when the edge / distance ratio is greater than this value. E.g. for default value 1000 two straight border edges are collapsed if the central vertex dist from the straight line composed by the two edges less than a 1/1000 of the sum of the edges length. Larger values enforce that only vertexes very close to the line are removed.\"/>
        <Param name=\"UnifyVertices\" description=\"UnifyVertices\" value=\"$unify_V\" type=\"RichBool\" tooltip=\"if true the snap vertices are weld together.\"/>
    </filter>" >> "$ml_SF"
}

### End Cleaning & Repair ###


### Begin Selection & Deletion ###

mlx_sel_none() {
    # Options & Defaults
    local allF="true" # If true the filter will de-select all the faces.
    local allV="true" # If true the filter will de-select all the vertices.
    
    # Other
    local i
    
    for i in "$@"; do
        case $i in
            all[fF]=*|[fF]=*|[fF]aces=*)
                allF="${i#*=}"
                shift # past argument=value
                ;;
            all[vV]=*|[vV]=*|[vV]ertexes=*|[vV]ertices=*)
                allV="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done
    
    echo "\
    <filter name=\"Select None\">
        <Param name=\"allFaces\" description=\"De-select all Faces\" value=\"$allF\" type=\"RichBool\" tooltip=\"If true the filter will de-select all the faces.\"/>
        <Param name=\"allVerts\" description=\"De-select all Vertices\" value=\"$allV\" type=\"RichBool\" tooltip=\"If true the filter will de-select all the vertices.\"/>
    </filter>" >> "$ml_SF"
}

mlx_invert_sel() {
    # Options & Defaults
    local invF="true" # If true the filter will de-select all the faces.
    local invV="true" # If true the filter will de-select all the vertices.
    
    # Other
    local i
    
    for i in "$@"; do
        case $i in
            inv[fF]=*|[fF]=*|[fF]aces=*)
                invF="${i#*=}"
                shift # past argument=value
                ;;
            inv[vV]=*|[vV]=*|[vV]ertexes=*|[vV]ertices=*)
                invV="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done

    echo "\
    <filter name=\"Invert Selection\">
        <Param name=\"InvFaces\" description=\"Invert Faces\" value=\"$invF\" type=\"RichBool\" tooltip=\"If true  the filter will invert the selected faces.\"/>
        <Param name=\"InvVerts\" description=\"Invert Vertices\" value=\"$invV\" type=\"RichBool\" tooltip=\"If true the filter will invert the selected vertices.\"/>
    </filter>" >> "$ml_SF"
}

mlx_sel_border() {
    # Selects mesh boundary edges, e.g. holes in solid models or the edges of surfaces
    echo "    <filter name=\"Select Border\"/>" >> "$ml_SF"
}

# Usage: iterations=(1)
mlx_grow_sel() {
    # Options & Defaults
    local iterations=1
    
    # Other
    local i
    local j
    
    for i in "$@"; do
        case $i in
            [iI]=*|[iI]terations=*)
                iterations="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done
    
    j=0
    while [ $j -lt $iterations ]; do 
        echo "    <filter name=\"Dilate Selection\"/>" >> "$ml_SF"
        j=$(($j+1))
    done
}

# Usage: iterations=(1)
mlx_shrink_sel() {
    # Options & Defaults
    local iterations=1
    
    # Other
    local i
    local j
    
    for i in "$@"; do
    case $i in
        [iI]=*|[iI]terations=*)
            iterations="${i#*=}"
            shift # past argument=value
            ;;
        *)
            # unknown option
            ;;
    esac
    done
    
    j=0
    while [ $j -lt $iterations ]; do 
        echo "    <filter name=\"Erode Selection\"/>" >> "$ml_SF"
        j=$(($j+1))
    done
}

mlx_sel_self_intersecting_F() {
    echo "    <filter name=\"Select Self Intersecting Faces\"/>" >> "$ml_SF"
}

mlx_sel_nonmanifold_V() {
    echo "    <filter name=\"Select non Manifold Vertices\"/>" >> "$ml_SF"
}

mlx_del_nonmanifold_V() {
    mlx_sel_nonmanifold_V
    mlx_del_sel_V
    #mlx_del_unreferenced_V
}

mlx_sel_nonmanifold_E() {
    echo "    <filter name=\"Select non Manifold Edges \"/>" >> "$ml_SF"
}

mlx_del_nonmanifold_E() {
    mlx_sel_nonmanifold_E
    mlx_del_sel_V
    #mlx_del_unreferenced_V
}

# Usage: ratio=(0.2)
mlx_sel_small_parts() {
    # Options & Defaults
    local ratio="0.2" # Small part ratio, this ratio (between 0 and 1) defines the meaning of "small" as the threshold ratio between the number of faces of the largest part and the other ones. A larger value will select more parts.
    local NonClosedOnly="false" # Select only non closed components
    
    # Other
    local i
    
    for i in "$@"; do
        case $i in
            [rR]=*|ratio=*)
                ratio="${i#*=}"
                shift # past argument=value
                ;;
            ratio[pP]erc=*) # provide ratio in percentage form, 1-100
                ratio=$(bc <<< "0.01 * ${i#*=}")
                shift #
                ;;
            [nN]on[cC]losed[oO]nly=*)
                NonClosedOnly="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done
    
    echo "\
    <filter name=\"Small component selection\">
        <Param name=\"NbFaceRatio\" description=\"Small component ratio\"value=\"$ratio\" type=\"RichFloat\" tooltip=\"This ratio (between 0 and 1) defines the meaning of &lt;i>small&lt;/i> as the threshold ratio between the number of faces of the largest component and the other ones. A larger value will select more components.\"/>
        <Param name=\"NonClosedOnly\" description=\"Select only non closed components\" value=\"$NonClosedOnly\" type=\"RichBool\" tooltip=\"\"/>
    </filter>" >> "$ml_SF"
}

# Usage: ratio=(0.2)
mlx_del_small_parts() {
    mlx_sel_small_parts "$@"
    mlx_del_sel_V_F
}

mlx_del_sel_V() {
    echo "    <filter name=\"Delete Selected Vertices\"/>" >> "$ml_SF"
}

mlx_del_sel_F() {
    echo "    <filter name=\"Delete Selected Faces\"/>" >> "$ml_SF"
}

mlx_del_sel_V_F() {
    echo "    <filter name=\"Delete Selected Faces and Vertices\"/>" >> "$ml_SF"
}

mlx_del_F_from_nonmanifold_E () {
    echo "    <filter name=\"Remove Faces from Non Manifold Edges\"/>" >> "$ml_SF"
    mlx_del_unreferenced_V
}

mlx_del_unreferenced_V() {
    echo "    <filter name=\"Remove Unreferenced Vertex\"/>" >> "$ml_SF"
}

mlx_del_duplicate_F() {
    echo "    <filter name=\"Remove Duplicate Faces\"/>" >> "$ml_SF"
}

mlx_del_duplicate_V(){
    echo "    <filter name=\"Remove Duplicated Vertex\"/>" >> "$ml_SF"
}

mlx_del_zero_area_F() {
    echo "    <filter name=\"Remove Zero Area Faces\"/>" >> "$ml_SF"
}

# TODO: set min & max better
mlx_sel_V_quality() {
    # Options & Defaults
    local minQ=0 # Minimum acceptable quality value
    local maxQ=0.05 # Maximum acceptable quality value
    local inclusive="true" # If true only the faces with all the vertices within the specified range are selected. Otherwise any face with at least one vertex within the range is selected.
    
    # Other
    local i
    
    for i in "$@"; do
        case $i in
            min[qQ]=*)
                minQ="${i#*=}"
                shift # past argument=value
                ;;
            max[qQ]=*)
                maxQ="${i#*=}"
                shift # past argument=value
                ;;
            inclusive=*)
                inclusive="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done
    
    echo "\
    <filter name=\"Select by Vertex Quality\">
        <Param name=\"minQ\" description=\"Min Quality\" value=\"$minQ\" min=\"0\" max=\"0.0888322\" type=\"RichDynamicFloat\" tooltip=\"Minimum acceptable quality value\"/>
        <Param name=\"maxQ\" description=\"Max Quality\" value=\"$maxQ\" min=\"0\" max=\"0.0888322\" type=\"RichDynamicFloat\" tooltip=\"Maximum acceptable quality value\"/>
        <Param name=\"Inclusive\" description=\"Inclusive Sel.\" value=\"$inclusive\" type=\"RichBool\" tooltip=\"If true only the faces with &lt;b>all&lt;/b> the vertices within the specified range are selected. Otherwise any face with at least one vertex within the range is selected.\"/>
    </filter>" >> "$ml_SF"
}


### End Selection & Deletion ###


### Begin Transformations ###

# Usage: X=(0) Y=(0) Z=(0)
# Usage: transX(mm) transY(mm) transZ(mm)
mlx_translate() {
    # Options & Defaults
    local transX=0 # Amount to translate in the X axis
    local transY=0 # Amount to translate in the Y axis
    local transZ=0 # Amount to translate in the Z axis
    local center="false" # Translate the center of the BBox to the origin
    local freeze="true" # The transformation is explicitly applied and the vertex coords are actually changed
    local allLayers="false" # The transformation is explicitly applied to all the mesh and raster layers in the project
    
    # Other
    local i
    
    for i in "$@"; do
        case $i in
            [xX]=*)
                transX="${i#*=}"
                shift # past argument=value
                ;;
            [yY]=*)
                transY="${i#*=}"
                shift # past argument=value
                ;;
            [zZ]=*)
                transZ="${i#*=}"
                shift # past argument=value
                ;;
            center=*)
                center="${i#*=}"
                shift # past argument=value
                ;;
            freeze=*)
                freeze="${i#*=}"
                shift # past argument=value
                ;;
            all[lL]ayers=*|all=*)
                allLayers="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done
    
    echo "\
    <filter name=\"Transform: Move, Translate, Center\">
        <Param name=\"axisX\" description=\"X Axis\" value=\"$transX\" min=\"-500\" max=\"500\" type=\"RichDynamicFloat\" tooltip=\"Absolute translation amount along the X axis\"/>
        <Param name=\"axisY\" description=\"Y Axis\" value=\"$transY\" min=\"-500\" max=\"500\" type=\"RichDynamicFloat\" tooltip=\"Absolute translation amount along the Y axis\"/>
        <Param name=\"axisZ\" description=\"Z Axis\" value=\"$transZ\" min=\"-500\" max=\"500\" type=\"RichDynamicFloat\" tooltip=\"Absolute translation amount along the Z axis\"/>
        <Param name=\"centerFlag\" description=\"translate center of bbox to the origin\" value=\"$center\"type=\"RichBool\" tooltip=\"If selected, the object is scaled to a box whose sides are at most 1 unit length\"/>
        <Param name=\"Freeze\" description=\"Freeze Matrix\" value=\"$freeze\" type=\"RichBool\" tooltip=\"The transformation is explicitly applied and the vertex coords are actually changed\"/>
        <Param name=\"ToAll\" description=\"Apply to all layers\" value=\"$allLayers\" type=\"RichBool\" tooltip=\"The transformation is explicitly applied to all the mesh and raster layers in the project\"/>
    </filter>" >> "$ml_SF"
}

# TODO: add center of mass & barycenter as a center point option for rotate and scale. Or just pass this as a customCenter

# Usage: axis=angle axis=angle ...
# NOTE: additional axis=angle pairs will stack and will be applied in the order listed
# set options before defining rotation amount
mlx_rotate() {
    # Options & Defaults
    local axis=2 # Axis to rotate about; can be X(0), Y(1), Z(2) or custom(3)
    local angle=0 # Angle of rotation; from -360 to +360 degrees
    local customAxis=( 0 0 1 ) # A vector defining the custom axis to rotate about. This rotation axis is used only if the "custom" axis option is used.
    local center=0 # The center point to rotate about; origin(0), barycenter(1), or custom(2)
    local customCenter=( 0 0 0 ) # A vector defining the custom center point to rotate about. This rotation center is used only if the "custom" center option is used.
    local freeze="true" # The transformation is explicitly applied and the vertex coords are actually changed
    local allLayers="false" # The transformation is explicitly applied to all the mesh and raster layers in the project
    
    # Other
    local i
    
    for i in "$@"; do
        case $i in
            [xX]=*)
                axis=0 # X axis
                angle="${i#*=}"
                write_rotate
                shift # past argument=value
                ;;
            [yY]=*)
                axis=1 # Y axis
                angle="${i#*=}"
                write_rotate
                shift # past argument=value
                ;;
            [zZ]=*)
                axis=2 # Z axis
                angle="${i#*=}"
                write_rotate
                shift # past argument=value
                ;;
            custom=*)
                axis=3 # Custom axis
                if [[ " ${customAxis[@]} " = " 0 0 1 " ]]; then
                    echo ; echo "WARNING: a custom axis was selected, however \"customAxis=\" was not provided. Using default (Z) instead."
                fi
                angle="${i#*=}"
                write_rotate
                shift # past argument=value
                ;;
            custom[aA]xis=*)
                OIFS="$IFS"; IFS=,; read -a customAxis <<< "${i#*=}"; IFS="$OIFS"
                for ((j=0; j<${#customAxis[@]}; j++)); do
                    if [ -z ${customAxis[$j]} ]; then customAxis[$j]=0; fi
                    #echo "end j=\"${customAxis[$j]}\""
                done
                #echo "Size of array = ${#customAxis[@]}"
                if [ ${#customAxis[@]} -eq 2 ]; then customAxis[2]=0; fi # sets z axis to 0 if left blank
                #echo "customAxis = ( ${customAxis[@]} )"
                shift # past argument=value
                ;;
            center=*) # 0=origin, 1=barycenter, 2=custom
                case "${i#*=}" in
                    origin )
                        center=0
                        ;;
                    barycenter )
                        center=1
                        ;;
                    custom )
                        center=2
                        if [[ " ${customCenter[@]} " = " 0 0 0 " ]]; then
                            echo ; echo "WARNING: a custom center point was selected, however \"customCenter=\" was not provided. Using default (origin) instead."
                        fi
                        ;;
                    * )
                        center=0
                        ;;
                esac
                shift # past argument=value
                ;;
            custom[cC]enter=*)
                OIFS="$IFS"; IFS=,; read -a customCenter <<< "${i#*=}"; IFS="$OIFS"
                for ((j=0; j<${#customCenter[@]}; j++)); do
                    if [ -z ${customCenter[$j]} ]; then customCenter[$j]=0; fi
                    #echo "end j=\"${customCenter[$j]}\""
                done
                if [ ${#customCenter[@]} -eq 2 ]; then customCenter[2]=0; fi # sets z axis to 0 if left blank
                #echo "customCenter = ( ${customCenter[@]} )"
                shift # past argument=value
                ;;
            freeze=*)
                freeze="${i#*=}"
                shift # past argument=value
                ;;
            all[lL]ayers=*|all=*)
                allLayers="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done
}

write_rotate() {
    echo "\
        <filter name=\"Transform: Rotate\">
            <Param name=\"rotAxis\" description=\"Rotation on:\" value=\"$axis\" enum_val0=\"X axis\" enum_val1=\"Y axis\" enum_val2=\"Z axis\" enum_val3=\"custom axis\"  enum_cardinality=\"4\" type=\"RichEnum\" tooltip=\"Choose a method\"/>
            <Param name=\"rotCenter\" description=\"Center of rotation:\" value=\"$center\" enum_val0=\"origin\" enum_val1=\"barycenter\" enum_val2=\"custom point\" enum_cardinality=\"3\" type=\"RichEnum\" tooltip=\"Choose a method\"/>
            <Param name=\"angle\" description=\"Rotation Angle\" value=\"$angle\" min=\"-360\" max=\"360\" type=\"RichDynamicFloat\" tooltip=\"Angle of rotation (in &lt;b>degree&lt;/b>). If snapping is enabled this value is rounded according to the snap value\"/>
            <Param name=\"snapFlag\" description=\"Snap angle\" value=\"false\" type=\"RichBool\" tooltip=\"If selected, before starting the filter will remove any unreferenced vertex (for which curvature values are not defined)\"/>
            <Param name=\"customAxis\" description=\"Custom axis\" x=\"${customAxis[0]}\" y=\"${customAxis[1]}\" z=\"${customAxis[2]}\" type=\"RichPoint3f\" tooltip=\"This rotation axis is used only if the 'custom axis' option is chosen.\"/>
            <Param name=\"customCenter\" description=\"Custom center\" x=\"${customCenter[0]}\" y=\"${customCenter[1]}\" z=\"${customCenter[2]}\" type=\"RichPoint3f\" tooltip=\"This rotation center is used only if the 'custom point' option is chosen.\"/>
            <Param name=\"snapAngle\" description=\"Snapping Value\" value=\"30\" type=\"RichFloat\" tooltip=\"This value is used to snap the rotation angle.\"/>
            <Param name=\"Freeze\" description=\"Freeze Matrix\" value=\"$freeze\" type=\"RichBool\" tooltip=\"The transformation is explicitly applied and the vertex coords are actually changed\"/>
            <Param name=\"ToAll\" description=\"Apply to all layers\" value=\"$allLayers\" type=\"RichBool\" tooltip=\"The transformation is explicitly applied to all the mesh and raster layers in the project\"/>
        </filter>" >> "$ml_SF"
}

# Usage: scale=(1)|(X=(1) Y=(1) Z=(1))
mlx_scale() {
    # Options & Defaults
    local scaleX=1 # amount to scale in X axis
    local scaleY=1 # amount to scale in Y axis
    local scaleZ=1 # amount to scale in Z axis
    local uniform="true" # If true an uniform scaling (the same for all three axes) is applied.
    local center=0 # The center point to scale about;  origin(0), barycenter(1), or custom(2)
    local customCenter=( 0 0 0 ) # A vector defining the custom center point to scale about. This rotation center is used only if the "custom" center option is used.
    local unit="false" # If true the object is scaled to a box whose sides are at most 1 unit length
    local freeze="true" # The transformation is explicitly applied and the vertex coords are actually changed
    local allLayers="false" # The transformation is explicitly applied to all the mesh and raster layers in the project
    
    # Other
    local i
    
    for i in "$@"; do
        case $i in
            s=*|scale=*)
                scaleX="${i#*=}"
                scaleY="${i#*=}"
                scaleZ="${i#*=}"
                uniform="true"
                shift # past argument=value
                ;;
            [xX]=*)
                scaleX="${i#*=}"
                uniform="false"
                shift # past argument=value
                ;;
            [yY]=*)
                scaleY="${i#*=}"
                uniform="false"
                shift # past argument=value
                ;;
            [zZ]=*)
                scaleZ="${i#*=}"
                uniform="false"
                shift # past argument=value
                ;;
            center=*) # 0=origin, 1=barycenter, 2=custom
                case "${i#*=}" in
                    origin )
                        center=0
                        ;;
                    barycenter )
                        center=1
                        ;;
                    custom )
                        center=2
                        if [[ " ${customCenter[@]} " = " 0 0 0 " ]]; then
                            echo ; echo "WARNING: a custom center point was selected, however \"customCenter=\" was not provided. Using default (origin) instead."
                        fi
                        ;;
                    * )
                        center=0
                        ;;
                esac
                shift # past argument=value
                ;;
            custom[cC]enter=*)
                OIFS="$IFS"; IFS=,; read -a customCenter <<< "${i#*=}"; IFS="$OIFS"
                for ((j=0; j<${#customCenter[@]}; j++)); do
                    if [ -z ${customCenter[$j]} ]; then customCenter[$j]=0; fi
                    #echo "end j=\"${customCenter[$j]}\""
                done
                if [ ${#customCenter[@]} -eq 2 ]; then customCenter[2]=0; fi # sets z axis to 0 if left blank
                #echo "customCenter = ( ${customCenter[@]} )"
                shift # past argument=value
                ;;
            unit=*)
                unit="${i#*=}"
                shift # past argument=value
                ;;
            freeze=*)
                freeze="${i#*=}"
                shift # past argument=value
                ;;
            all[lL]ayers=*|all=*)
                allLayers="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done
    
    echo "\
    <filter name=\"Transform: Scale\">
        <Param name=\"axisX\" description=\"X Axis\" value=\"$scaleX\" type=\"RichFloat\" tooltip=\"Scaling\"/>
        <Param name=\"axisY\" description=\"Y Axis\" value=\"$scaleY\" type=\"RichFloat\" tooltip=\"Scaling\"/>
        <Param name=\"axisZ\" description=\"Z Axis\" value=\"$scaleZ\" type=\"RichFloat\" tooltip=\"Scaling\"/>
        <Param name=\"uniformFlag\" description=\"Uniform Scaling\" value=\"$uniform\" type=\"RichBool\" tooltip=\"If selected an uniform scaling (the same for all the three axis) is applied (the X axis value is used)\"/>
        <Param name=\"scaleCenter\" description=\"Center of scaling:\" value=\"$center\" enum_val0=\"origin\" enum_val1=\"barycenter\" enum_val2=\"custom point\" enum_cardinality=\"3\" type=\"RichEnum\" tooltip=\"Choose a method\"/>
        <Param name=\"customCenter\" description=\"Custom center\" x=\"${customCenter[0]}\" y=\"${customCenter[1]}\" z=\"${customCenter[2]}\" type=\"RichPoint3f\" tooltip=\"This scaling center is used only if the 'custom point' option is chosen.\"/>
        <Param name=\"unitFlag\" description=\"Scale to Unit bbox\" value=\"$unit\" type=\"RichBool\" tooltip=\"If selected, the object is scaled to a box whose sides are at most 1 unit length\"/>
        <Param name=\"Freeze\" description=\"Freeze Matrix\" value=\"$freeze\" type=\"RichBool\" tooltip=\"The transformation is explicitly applied and the vertex coords are actually changed\"/>
        <Param name=\"ToAll\" description=\"Apply to all layers\" value=\"$allLayers\" type=\"RichBool\" tooltip=\"The transformation is explicitly applied to all the mesh and raster layers in the project\"/>
    </filter>" >> "$ml_SF"
}

mlx_freeze_matrix() {
    # Options & Defaults
    local allLayers="false" # The transformation is explicitly applied to all the mesh and raster layers in the project
    
    # Other
    local i
    
    for i in "$@"; do
        case $i in
            all[lL]ayers=*|all=*)
                allLayers="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done

    echo "\
    <filter name=\"Freeze Current Matrix\">
        <Param name=\"allLayers\" description=\"Apply to all visible Layers\" value=\"$allLayers\" type=\"RichBool\" tooltip=\"If selected the filter will be applied to all visible layers\"/>
    </filter>" >> "$ml_SF"
}

### End Transformations ###


### Begin Remeshing ###

# Usage: faces=(25000)
# TIP: measure topology fist to find number of faces and area
mlx_simplify() {
    # Options & Defaults
    local faces=25000 # Target number of faces
    local targetPerc=0 # If non zero, this parameter specifies the desired final size of the mesh as a percentage of the initial mesh.
    local qualityThr="0.3" # Quality threshold for penalizing bad shaped faces. The value is in the range [0..1; 0 accept any kind of face (no penalties), 0.5  penalize faces with quality <0.5, proportionally to their shape.
    local preserveBoundary="false" # The simplification process tries not to destroy mesh boundaries
    local boundaryWeight=1 # The importance of the boundary during simplification. Default (1.0) means that the boundary has the same importance of the rest. Values greater than 1.0 raise boundary importance and has the effect of removing less vertices on the border. Admitted range of values (0,+inf).
    local preserveNormal="false" # Try to avoid face flipping effects and try to preserve the original orientation of the surface
    local optimalPlacement="true" # Each collapsed vertex is placed in the position minimizing the quadric error. It can fail (creating bad spikes) in case of very flat areas. If false edges are collapsed onto one of the two original vertices and the final mesh is composed by a subset of the original vertices.
    local planarQuadric="false" # Add additional simplification constraints that improves the quality of the simplification of the planar portion of the mesh.
    local selected="false" # If true the filter affects only the selected faces.
    
    # Options & Defaults - with texture
    local extraTexCoordWeight=1 # Additional weight for each extra Texture Coordinates for every (selected) vertex
    
    # Options & Defaults - without texture
    local preserveTopology="true" # Avoid all the collapses that should cause a topology change in the mesh (like closing holes, squeezing handles, etc). If checked the genus of the mesh should stay unchanged.
    local qualityWeight="false" # Use the Per-Vertex quality as a weighting factor for the simplification. The weight is used as a error amplification value, so a vertex with a high quality value will not be simplified and a portion of the mesh with low quality values will be aggressively simplified.
    local autoClean="true" # After the simplification an additional set of steps is performed to clean the mesh (unreferenced vertices, bad faces, etc).
    
    # Other
    local i
    
    if [ -z "$m_color" ]; then do_subfiles "$ml_IF"; fi # set m_color based on input file
    
    # TODO: add warnings if options are specified that do not apply
    
    for i in "$@"; do
        case $i in
            [fF]=*|faces=*)
                faces="${i#*=}"
                shift # past argument=value
                ;;
            target[pP]erc=*) # TODO: should this be 0-100 like other percentages?
                targetPerc="${i#*=}"
                shift # past argument=value
                ;;
            quality[tT]hr=*)
                qualityThr="${i#*=}"
                shift # past argument=value
                ;;
            preserve[bB]oundary=*)
                preserveBoundary="${i#*=}"
                shift # past argument=value
                ;;
            boundary[wW]eight=*)
                boundaryWeight="${i#*=}"
                shift # past argument=value
                ;;
            preserve[nN]ormal=*)
                preserveNormal="${i#*=}"
                shift # past argument=value
                ;;
            optimal[pP]lacement=*)
                optimalPlacement="${i#*=}"
                shift # past argument=value
                ;;
            planar[qQ]uadric=*)
                planarQuadric="${i#*=}"
                shift # past argument=value
                ;;
            sel=*|selected=*)
                selected="${i#*=}"
                shift # past argument=value
                ;;
            extra[tT]ex[cC]oord[wW]eight=*)
                extraTexCoordWeight="${i#*=}"
                shift # past argument=value
                ;;
            preserve[tT]opology=*)
                preserveTopology="${i#*=}"
                shift # past argument=value
                ;;
            quality[wW]eight=*)
                qualityWeight="${i#*=}"
                shift # past argument=value
                ;;
            auto[cC]lean=*)
                autoClean="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done
    
    if [ "$m_color" = "UV" ]; then
        echo "\
    <filter name=\"Quadric Edge Collapse Decimation (with texture)\">
        <Param name=\"TargetFaceNum\" description=\"Target number of faces\" value=\"$faces\" type=\"RichInt\" tooltip=\"\"/>
        <Param name=\"TargetPerc\" description=\"Percentage reduction (0..1)\" value=\"$targetPerc\" type=\"RichFloat\" tooltip=\"If non zero, this parameter specifies the desired final size of the mesh as a percentage of the initial mesh.\"/>
        <Param name=\"QualityThr\" description=\"Quality threshold\" value=\"$qualityThr\" type=\"RichFloat\" tooltip=\"Quality threshold for penalizing bad shaped faces.&lt;br>The value is in the range [0..1]&#xa; 0 accept any kind of face (no penalties),&#xa; 0.5  penalize faces with quality &lt; 0.5, proportionally to their shape&#xa;\"/>
        <Param name=\"Extratcoordw\" description=\"Texture Weight\" value=\"$extraTexCoordWeight\" type=\"RichFloat\" tooltip=\"Additional weight for each extra Texture Coordinates for every (selected) vertex\"/>
        <Param name=\"PreserveBoundary\" description=\"Preserve Boundary of the mesh\" value=\"$preserveBoundary\" type=\"RichBool\" tooltip=\"The simplification process tries not to destroy mesh boundaries\"/>
        <Param name=\"BoundaryWeight\" description=\"Boundary Preserving Weight\" value=\"$boundaryWeight\" type=\"RichFloat\" tooltip=\"The importance of the boundary during simplification. Default (1.0) means that the boundary has the same importance of the rest. Values greater than 1.0 raise boundary importance and has the effect of removing less vertices on the border. Admitted range of values (0,+inf).\"/>
        <Param name=\"OptimalPlacement\" description=\"Optimal position of simplified vertices\" value=\"$optimalPlacement\" type=\"RichBool\" tooltip=\"Each collapsed vertex is placed in the position minimizing the quadric error.&#xa; It can fail (creating bad spikes) in case of very flat areas. &#xa;If disabled edges are collapsed onto one of the two original vertices and the final mesh is composed by a subset of the original vertices.\"/>
        <Param name=\"PreserveNormal\" description=\"Preserve Normal\" value=\"$preserveNormal\" type=\"RichBool\" tooltip=\"Try to avoid face flipping effects and try to preserve the original orientation of the surface\"/>
        <Param name=\"PlanarQuadric\" description=\"Planar Simplification\" value=\"$planarQuadric\" type=\"RichBool\" tooltip=\"Add additional simplification constraints that improves the quality of the simplification of the planar portion of the mesh.\"/>
        <Param name=\"Selected\" description=\"Simplify only selected faces\" value=\"$selected\" type=\"RichBool\" tooltip=\"The simplification is applied only to the selected set of faces.&#xa; Take care of the target number of faces!\"/>
    </filter>" >> "$ml_SF"
    else
        echo "\
    <filter name=\"Quadric Edge Collapse Decimation\">
        <Param name=\"TargetFaceNum\" description=\"Target number of faces\" value=\"$faces\" type=\"RichInt\" tooltip=\"The desired final number of faces.\"/>
        <Param name=\"TargetPerc\" description=\"Percentage reduction (0..1)\" value=\"$targetPerc\" type=\"RichFloat\" tooltip=\"If non zero, this parameter specifies the desired final size of the mesh as a percentage of the initial size.\"/>
        <Param name=\"QualityThr\" description=\"Quality threshold\" value=\"$qualityThr\" type=\"RichFloat\" tooltip=\"Quality threshold for penalizing bad shaped faces.&lt;br>The value is in the range [0..1]&#xa; 0 accept any kind of face (no penalties),&#xa; 0.5  penalize faces with quality &lt; 0.5, proportionally to their shape&#xa;\"/>
        <Param name=\"PreserveBoundary\" description=\"Preserve Boundary of the mesh\" value=\"$preserveBoundary\" type=\"RichBool\" tooltip=\"The simplification process tries to do not affect mesh boundaries during simplification\"/>
        <Param name=\"BoundaryWeight\" description=\"Boundary Preserving Weight\" value=\"$boundaryWeight\" type=\"RichFloat\" tooltip=\"The importance of the boundary during simplification. Default (1.0) means that the boundary has the same importance of the rest. Values greater than 1.0 raise boundary importance and has the effect of removing less vertices on the border. Admitted range of values (0,+inf).\"/>
        <Param name=\"PreserveNormal\" description=\"Preserve Normal\" value=\"$preserveNormal\" type=\"RichBool\" tooltip=\"Try to avoid face flipping effects and try to preserve the original orientation of the surface\"/>
        <Param name=\"PreserveTopology\" description=\"Preserve Topology\" value=\"$preserveTopology\" type=\"RichBool\" tooltip=\"Avoid all the collapses that should cause a topology change in the mesh (like closing holes, squeezing handles, etc). If checked the genus of the mesh should stay unchanged.\"/>
        <Param name=\"OptimalPlacement\" description=\"Optimal position of simplified vertices\" value=\"$optimalPlacement\" type=\"RichBool\" tooltip=\"Each collapsed vertex is placed in the position minimizing the quadric error.&#xa; It can fail (creating bad spikes) in case of very flat areas. &#xa;If disabled edges are collapsed onto one of the two original vertices and the final mesh is composed by a subset of the original vertices.\"/>
        <Param name=\"PlanarQuadric\" description=\"Planar Simplification\" value=\"$planarQuadric\" type=\"RichBool\" tooltip=\"Add additional simplification constraints that improves the quality of the simplification of the planar portion of the mesh.\"/>
        <Param name=\"QualityWeight\" description=\"Weighted Simplification\" value=\"$qualityWeight\" type=\"RichBool\" tooltip=\"Use the Per-Vertex quality as a weighting factor for the simplification. The weight is used as a error amplification value, so a vertex with a high quality value will not be simplified and a portion of the mesh with low quality values will be aggressively simplified.\"/>
        <Param name=\"AutoClean\" description=\"Post-simplification cleaning\" value=\"$autoClean\" type=\"RichBool\" tooltip=\"After the simplification an additional set of steps is performed to clean the mesh (unreferenced vertices, bad faces, etc)\"/>
        <Param name=\"Selected\" description=\"Simplify only selected faces\" value=\"$selected\" type=\"RichBool\" tooltip=\"The simplification is applied only to the selected set of faces.&#xa; Take care of the target number of faces!\"/>
    </filter>" >> "$ml_SF"
    fi
}

# Usage: voxel=(1) delta=(0)
# If you prefer to use a precision (as a percentage of AABB[diag]) instead of the voxel cell size include the following code in the parent and pass voxel:
#   precision=1 # 1% of AABB[diag]
#   voxel=$(bc <<< "(${AABB[diag]} * 0.01 * $precision)")
mlx_offset() {
    # Options & Defaults
    local voxel=1 # Voxel cell size for resampling. Smaller cells give better precision at a higher computational cost. Remember that halving the cell size means that you build a volume 8 times larger.
    local delta=0 # offset amount; negative values offset inwards (inset)
    local merge_V="true" # If true the mesh generated by MC will be cleaned by unifying vertices that are almost coincident.
    local discretize="false" # If true the position of the intersected edge of the marching cube grid is not computed by linear interpolation, but it is placed in fixed middle position. As a consequence the resampled object will look severely aliased by a stairstep appearance. Useful only for simulating the output of 3D printing devices.
    local multisample="false" # If true the distance field is more accurately compute by multisampling the volume (7 sample for each voxel). Much slower but less artifacts.
    local thicken="false" # If true, you have to choose a not zero Offset and a double surface is built around the original surface, inside and outside. Is useful to convert thin floating surfaces into solid, thick meshes.
    
    # Other
    local i
    local voxelMax="100"
    local deltaMin="-100"
    local deltaMax="100"
    # AABB[diag] will be used to set maxes and mins if available
    if [ -n "${AABB[diag]}" ]; then
        voxelMax="${AABB[diag]}"
        deltaMin=$(bc <<< "(${AABB[diag]} * 0.2 * -1)") #-20% of AABB[diag]
        deltaMax=$(bc <<< "(${AABB[diag]} * 0.2)") #+20% of AABB[diag]
    fi
    
    for i in "$@"; do
        case $i in
            voxel=*)
                voxel="${i#*=}"
                shift # past argument=value
                ;;
            d=*|delta=*)
                delta="${i#*=}"
                shift # past argument=value
                ;;
            merge_V=*)
                merge_V="${i#*=}"
                shift # past argument=value
                ;;
            discretize=*)
                discretize="${i#*=}"
                shift # past argument=value
                ;;
            multisample=*)
                multisample="${i#*=}"
                shift # past argument=value
                ;;
            thicken=*)
                thicken="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done
    
    echo "\
    <filter name=\"Uniform Mesh Resampling\">
        <Param name=\"CellSize\" description=\"Precision\" value=\"$voxel\" min=\"0\" max=\"$voxelMax\" type=\"RichAbsPerc\" tooltip=\"Size of the cell, the default is 1/50 of the box diag. Smaller cells give better precision at a higher computational cost. Remember that halving the cell size means that you build a volume 8 times larger.\"/>
        <Param name=\"Offset\" description=\"Offset\" value=\"$delta\" min=\"$deltaMin\" max=\"$deltaMax\" type=\"RichAbsPerc\" tooltip=\"Offset of the created surface (i.e. distance of the created surface from the original one).&lt;br>If offset is zero, the created surface passes on the original mesh itself. Values greater than zero mean an external surface, and lower than zero mean an internal surface.&lt;br> In practice this value is the threshold passed to the Marching Cube algorithm to extract the isosurface from the distance field representation.\"/>
        <Param name=\"mergeCloseVert\" description=\"Clean Vertices\" value=\"$merge_V\" type=\"RichBool\" tooltip=\"If true the mesh generated by MC will be cleaned by unifying vertices that are almost coincident\"/>
        <Param name=\"discretize\" description=\"Discretize\" value=\"$discretize\" type=\"RichBool\" tooltip=\"If true the position of the intersected edge of the marching cube grid is not computed by linear interpolation, but it is placed in fixed middle position. As a consequence the resampled object will look severely aliased by a stairstep appearance.&lt;br>Useful only for simulating the output of 3D printing devices.\"/>
        <Param name=\"multisample\" description=\"Multisample\" value=\"$multisample\" type=\"RichBool\" tooltip=\"If true the distance field is more accurately compute by multisampling the volume (7 sample for each voxel). Much slower but less artifacts.\"/>
        <Param name=\"absDist\" description=\"Absolute Distance\" value=\"$thicken\" type=\"RichBool\" tooltip=\"If true a &lt;b> not&lt;/b> signed distance field is computed. In this case you have to choose a not zero Offset and a double surface is built around the original surface, inside and outside. Is useful to convert thin floating surfaces into &lt;i> solid, thick meshes.&lt;/i>.\"/>
    </filter>" >> "$ml_SF"
}

# Usage: iterations=(1)
mlx_subdivide() {
    # Options & Defaults
    local method="loop" # Method to use; currently only Loop is implemented but others may be added later
    local iterations=1 # Number of times the model is subdivided.
    local loopWeight=0 # Change the weighting scheme used; optimize some behaviors in spite of others. Values: loop(0), enhanceRegularity(1), enhanceContinuity(2)
    local E_threshold=0 # Edge threshold: all the edges longer than this threshold will be refined. Setting this value to zero will force an uniform refinement.
    local selected="false" # If true the filter affects only the selected faces.
    
    # Other
    local i
    
    for i in "$@"; do
        case $i in
            [iI]=*|[iI]terations=*)
                iterations="${i#*=}"
                shift # past argument=value
                ;;
            loop[wW]eight=*) # 0=loop, 1=enhanceRegularity, 2=enhanceContinuity
                case "${i#*=}" in
                    loop )
                        loopWeight=0
                        ;;
                    enhance[rR]egularity )
                        loopWeight=1
                        ;;
                    enhance[cC]ontinuity )
                        loopWeight=2
                        ;;
                    * )
                        loopWeight=0
                        ;;
                esac
                shift # past argument=value
                ;;
            E_threshold=*)
                E_threshold="${i#*=}"
                shift # past argument=value
                ;;
            sel=*|selected=*)
                selected="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done
    
    echo "\
    <filter name=\"Subdivision Surfaces: Loop\">
        <Param name=\"LoopWeight\" description=\"Weighting scheme\" value=\"$loopWeight\" enum_val0=\"Loop\" enum_val1=\"Enhance regularity\" enum_val2=\"Enhance continuity\" enum_cardinality=\"3\" type=\"RichEnum\" tooltip=\"Change the weights used. Allow to optimize some behaviours in spite of others.\"/>
        <Param name=\"Iterations\" description=\"Iterations\" value=\"$iterations\" type=\"RichInt\" tooltip=\"Number of times the model is subdivided.\"/>
        <Param name=\"Threshold\" description=\"Edge Threshold\" value=\"$E_threshold\" min=\"0\" max=\"100\" type=\"RichAbsPerc\" tooltip=\"All the edges &lt;b>longer&lt;/b> than this threshold will be refined.&lt;br>Setting this value to zero will force an uniform refinement.\"/>
        <Param name=\"Selected\" description=\"Affect only selected faces\" value=\"$selected\" type=\"RichBool\" tooltip=\"If selected the filter affect only the selected faces\"/>
    </filter>" >> "$ml_SF"
}

# Usage: iterations=(1)
mlx_smooth() {
    # Options & Defaults
    local method="laplacian" # Method to use; currently only Laplacian is implemented but others (Taubin, etc.) may be added later
    local iterations=1 # The number of times that the whole algorithm (normal smoothing + vertex fitting) is iterated.
    local boundary="true" # If true the boundary edges are smoothed only by themselves (e.g. the polyline forming the boundary of the mesh is independently smoothed). Can reduce the shrinking on the border but can have strange effects on very small boundaries.
    local cotangentWeight="true" # Cotangent weighting: if true the cotangent weighting scheme is computed for the averaging of the position. Otherwise (false) the simpler umbrella scheme (1 if the edge is present) is used.
    local selected="false" # If true the filter affects only the selected faces.
    
    # Other
    local i
    
    for i in "$@"; do
        case $i in
            [iI]=*|[iI]terations=*)
                iterations="${i#*=}"
                shift # past argument=value
                ;;
            boundary=*)
                boundary="${i#*=}"
                shift # past argument=value
                ;;
            cotangent[wW]eight=*)
                cotangentWeight="${i#*=}"
                shift # past argument=value
                ;;
            sel=*|selected=*)
                selected="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done
    
    echo "\
    <filter name=\"Laplacian Smooth\">
        <Param name=\"stepSmoothNum\" description=\"Smoothing steps\" value=\"$iterations\" type=\"RichInt\" tooltip=\"The number of times that the whole algorithm (normal smoothing + vertex fitting) is iterated.\"/>
        <Param name=\"Boundary\" description=\"1D Boundary Smoothing\" value=\"$boundary\" type=\"RichBool\" tooltip=\"If true the boundary edges are smoothed only by themselves (e.g. the polyline forming the boundary of the mesh is independently smoothed). Can reduce the shrinking on the border but can have strange effects on very small boundaries.\"/>
        <Param name=\"cotangentWeight\" description=\"Cotangent weighting\" value=\"$cotangentWeight\" type=\"RichBool\" tooltip=\"If true the cotangent weighting scheme is computed for the averaging of the position. Otherwise (false) the simpler umbrella scheme (1 if the edge is present) is used.\"/>
        <Param name=\"Selected\" description=\"Affect only selected faces\" value=\"$selected\" type=\"RichBool\" tooltip=\"If checked the filter is performed only on the selected faces\"/>
    </filter>" >> "$ml_SF"
}

mlx_hull() {
    # Options & Defaults
    local reorient_normals="true" # Re-orient all faces coherently after hull operation.
    
    # Other
    local i
    
    for i in "$@"; do
        case $i in
            reorient=*|reorient_normals=*)
                reorient_normals="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done

    echo "\
    <filter name=\"Convex Hull\">
        <Param name=\"reorient\" description=\"Re-orient all faces coherentely\" value=\"$reorient_normals\" type=\"RichBool\" tooltip=\"Re-orient all faces coherentely\"/>
    </filter>" >> "$ml_SF"
}

mlx_reconstruct_surface() {
    # Options & Defaults
    local method="poisson" # Method to use; currently only Poisson is implemented but others (Ball pivoting & VCG) may be added later
    
    # Poisson options:
    local octreeDepth=10 # Set the depth of the Octree used for extracting the final surface. Suggested range 5..10. Higher numbers mean higher precision in the reconstruction but also higher processing times. Be patient.
    local solverDivide=8 # This integer argument specifies the depth at which a block Gauss-Seidel solver is used to solve the Laplacian equation. Using this parameter helps reduce the memory overhead at the cost of a small increase in reconstruction time. In practice, the authors have found that for reconstructions of depth 9 or higher a subdivide depth of 7 or 8 can reduce the memory usage. The default value is 8.
    local samplesPerNode=1 # This floating point value specifies the minimum number of sample points that should fall within an octree node as the octree construction is adapted to sampling density. For noise-free samples, small values in the range [1.0 - 5.0] can be used. For more noisy samples, larger values in the range [15.0 - 20.0] may be needed to provide a smoother, noise-reduced, reconstruction. The default value is 1.0.
    local offset=1 # Surface offsetting: this floating point value specifies a correction value for the isosurface threshold that is chosen. Values <1 means internal offsetting, >1 external offsetting. Good values are in the range 0.5 .. 2. The default value is 1.0 (no offsetting).
    
    # Other
    local i
    
    for i in "$@"; do
        case $i in
            octree[dD]epth=*)
                octreeDepth="${i#*=}"
                shift # past argument=value
                ;;
            solver[dD]ivide=*)
                solverDivide="${i#*=}"
                shift # past argument=value
                ;;
            samples[pP]er[nN]ode=*)
                samplesPerNode="${i#*=}"
                shift # past argument=value
                ;;
            offset=*)
                offset="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done
    
    echo "\
    <filter name=\"Surface Reconstruction: Poisson\">
        <Param name=\"OctDepth\" description=\"Octree Depth\" value=\"$octreeDepth\" type=\"RichInt\" tooltip=\"Set the depth of the Octree used for extracting the final surface. Suggested range 5..10. Higher numbers mean higher precision in the reconstruction but also higher processing times. Be patient.&#xa;\"/>
        <Param name=\"SolverDivide\" description=\"Solver Divide\" value=\"$solverDivide\" type=\"RichInt\" tooltip=\"This integer argument specifies the depth at which a block Gauss-Seidel solver is used to solve the Laplacian equation.&#xa;Using this parameter helps reduce the memory overhead at the cost of a small increase in reconstruction time. &#xa;In practice, the authors have found that for reconstructions of depth 9 or higher a subdivide depth of 7 or 8 can reduce the memory usage.&#xa;The default value is 8.&#xa;\"/>
        <Param name=\"SamplesPerNode\" description=\"Samples per Node\" value=\"$samplesPerNode\" type=\"RichFloat\" tooltip=\"This floating point value specifies the minimum number of sample points that should fall within an octree node as the octree&#xa;construction is adapted to sampling density. For noise-free samples, small values in the range [1.0 - 5.0] can be used.&#xa;For more noisy samples, larger values in the range [15.0 - 20.0] may be needed to provide a smoother, noise-reduced, reconstruction.&#xa;The default value is 1.0.\"/>
        <Param name=\"Offset\" description=\"Surface offsetting\" value=\"$offset\" type=\"RichFloat\" tooltip=\"This floating point value specifies a correction value for the isosurface threshold that is chosen.&#xa;Values &lt; 1 means internal offsetting, >1 external offsetting.Good values are in the range 0.5 .. 2.&#xa;The default value is 1.0 (no offsetting).\"/>
    </filter>" >> "$ml_SF"
}

### End Remeshing ###


### Begin Mesh Layers ###

# Usage: merge_V=(false)
# NOTE: filter will discard textures, creates a new layer "Merged Mesh"
#mlx_flatten_layers_merge_V looks to be a key one; experiment with this
mlx_flatten_layers() {
    # Options & Defaults
    local merge_V="false" # Merge the vertices that are duplicated among different layers. &lt;br>Very useful when the layers are spliced portions of a single big mesh.
    local keepUnreferenced_V="false" # Keep unreferenced vertices; if true do not discard unreferenced vertices from source layers. Necessary for point-only layers.
    local mergeVisible="true" # Merge only visible layers.
    local delLayer="true" # Delete all the merged layers. &lt;br>If all layers are visible only a single layer will remain after the invocation of this filter
    
    # Other
    local i
    
    for i in "$@"; do
        case $i in
            merge_V=*)
                merge_V="${i#*=}"
                shift # past argument=value
                ;;
            keep[uU]nreferenced_V=*)
                keepUnreferenced_V="${i#*=}"
                shift # past argument=value
                ;;
            merge[vV]isible=*)
                mergeVisible="${i#*=}"
                shift # past argument=value
                ;;
            del[lL]ayer=*)
                delLayer="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done

    echo "\
    <filter name=\"Flatten Visible Layers\">
        <Param name=\"MergeVisible\" description=\"Merge Only Visible Layers\" value=\"$mergeVisible\" type=\"RichBool\" tooltip=\"Merge the vertices that are duplicated among different layers. &lt;br>Very useful when the layers are spliced portions of a single big mesh.\"/>
        <Param name=\"DeleteLayer\" description=\"Delete Layers \" value=\"$delLayer\" type=\"RichBool\" tooltip=\"Delete all the merged layers. &lt;br>If all layers are visible only a single layer will remain after the invocation of this filter\"/>
        <Param name=\"MergeVertices\" description=\"Merge duplicate vertices\" value=\"$merge_V\" type=\"RichBool\" tooltip=\"Merge the vertices that are duplicated among different layers. &#xa;&#xa;Very useful when the layers are spliced portions of a single big mesh.\"/>
        <Param name=\"AlsoUnreferenced\" description=\"Keep unreferenced vertices\" value=\"$keepUnreferenced_V\" type=\"RichBool\" tooltip=\"Do not discard unreferenced vertices from source layers&#xa;&#xa;Necessary for point-only layers\"/>
    </filter>" >> "$ml_SF"
}

# deletes current layer
mlx_del_layer() {
    echo "    <filter name=\"Delete Current Mesh\"/>" >> "$ml_SF"
}

# Usage: label=name
# renames current layer label
mlx_rename_layer() {
    # Options & Defaults
    local label
    
    # Other
    local i
    
    for i in "$@"; do
        case $i in
            l=*|label=*)
                label="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done
    
    echo "\
    <filter name=\"Rename Current Mesh\">
        <Param name=\"newName\" description=\"New Label\" value=\"$label\" type=\"RichString\" tooltip=\"New Label for the mesh\"/>
    </filter>" >> "$ml_SF"
}

# Usage: layerNum=
mlx_change_layer() {
    # Options & Defaults
    local layerNum=0 #First (base) layer, usually the first input file unless its been deleted.
    
    # Other
    local i
    
    for i in "$@"; do
        case $i in
            l=*|layer[nN]um=*)
                layerNum="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done
    
    echo "\
    <filter name=\"Change the current layer\">
        <Param name=\"mesh\" description=\"Mesh\" value=\"$layerNum\" type=\"RichMesh\" tooltip=\"The name of the current mesh\"/>
    </filter>" >> "$ml_SF"
}

mlx_copy_layer() {
# creates new layer named "*_copy"
    echo "    <filter name=\"Duplicate Current layer\"/>" >> "$ml_SF"
}

mlx_split_parts() {
# Creates layers named "CC 0", "CC 1", etc.
# This doesn't preserve textures!
    echo "    <filter name=\"Split in Connected Components\"/>" >> "$ml_SF"
}

### End Mesh Layers ###


### Begin Create ###
# TODO: how to create new items without an input file? Import file then immediately delete layer as the first step is a valid workaround. Opening an empty mlp project didn't seem to work.

# Usage: size=(1)|(X=(1) Y=(1) Z=(1)) center=(false)
# Usage: (size(mm))|(sizeX(mm) sizeY(mm) sizeZ(mm)) [center(true|(false))]
mlx_cube() {
    # Options & Defaults
    local sizeX=1
    local sizeY=1
    local sizeZ=1
    local center="false"
    local color="" # specify a color name to apply vertex colors to the newly created mesh
    
    # Other
    local i
    
    # Box is centered on origin at creation
    echo "\
    <filter name=\"Box\">
        <Param name=\"size\" description=\"Scale factor\" value=\"1\" type=\"RichFloat\" tooltip=\"Scales the new mesh\"/>
    </filter>" >> "$ml_SF"
    
    for i in "$@"; do
        case $i in
            s=*|size=*)
                sizeX="${i#*=}"
                sizeY="${i#*=}"
                sizeZ="${i#*=}"
                shift # past argument=value
                ;;
            [xX]=*)
                sizeX="${i#*=}"
                shift # past argument=value
                ;;
            [yY]=*)
                sizeY="${i#*=}"
                shift # past argument=value
                ;;
            [zZ]=*)
                sizeZ="${i#*=}"
                shift # past argument=value
                ;;
            c=*|center=*)
                center="${i#*=}"
                shift # past argument=value
                ;;
            color=*)
                color="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done
    
    mlx_scale x="$sizeX" y="$sizeY" z="$sizeZ"
    if [ "$center" != "true" ]; then # center=false
        mlx_translate x=$(bc <<< "scale=10;($sizeX/2)") y=$(bc <<< "scale=10;($sizeY/2)") z=$(bc <<< "scale=10;($sizeZ/2)") 
    fi
    if [ -n "$color" ]; then
        mlx_color_V color="$color"
    fi
}

# Usage: height=(1) (radius=(1)|(radius1=(1) radius2=(1)))|(diameter=(2)|(diameter1=(2) diameter2=(2))) center=(false)
# Note: need to know m_up in order to orient cylinder correctly!
# OpenSCAD cylinder:
#    h This is the height of the cylinder. Default value is 1.
#    r The radius of both top and bottom ends of the cylinder. Use this parameter if you want plain cylinder. Default value is 1.
#    r1 This is the radius of the cone on bottom end. Default value is 1.
#    r2 This is the radius of the cone on top end. Default value is 1.
#    d The diameter of both top and bottom ends of the cylinder. Use this parameter if you want plain cylinder. Default value is 1.
#    d1 This is the diameter of the cone on bottom end. Default value is 1.
#    d2 This is the diameter of the cone on top end. Default value is 1.
#    center If true will center the height of the cone/cylinder around the origin. Default is false, placing the base of the cylinder or r1 radius of cone at the origin.
mlx_cylinder() {
    # Options & Defaults
    local height=1 # height of the cylinder
    local radius1=1 # radius of the cone on bottom end
    local radius2=1 # radius of the cone on top end
    local center="false" # If true will center the height of the cone/cylinder around the origin. Default is false, placing the base of the cylinder or r1 radius of cone at the origin.
    local color="" # specify a color name to apply vertex colors to the newly created mesh
    
    # Other
    local i

    if [ -z "$fn" ]; then fn="32"; fi
    
    for i in "$@"; do
        case $i in
            h=*|height=*)
                height="${i#*=}"
                shift # past argument=value
                ;;
            r=*|radius=*|rad=*)
                radius1="${i#*=}"
                radius2="$radius1"
                shift # past argument=value
                ;;
            r1=*|radius1=*|rad1=*)
                radius1="${i#*=}"
                shift # past argument=value
                ;;
            r2=*|radius2=*|rad2=*)
                radius2="${i#*=}"
                shift # past argument=value
                ;;
            d=*|diameter=*|dia=*)
                radius1=$(bc <<< "scale=10;(${i#*=} / 2)")
                radius2="$radius1"
                shift # past argument=value
                ;;
            d1=*|diameter1=*|dia1=*)
                radius1=$(bc <<< "scale=10;(${i#*=} / 2)")
                shift # past argument=value
                ;;
            d2=*|diameter2=*|dia2=*)
                radius2=$(bc <<< "scale=10;(${i#*=} / 2)")
                shift # past argument=value
                ;;
            c=*|center=*)
                center="${i#*=}"
                shift # past argument=value
                ;;
            fn=*)
                fn="${i#*=}"
                shift # past argument=value
                ;;
            color=*)
                color="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done
    
    # cone is created centered with Y up
    echo "\
    <filter name=\"Cone\">
        <Param name=\"r0\" description=\"Radius 1\" value=\"$radius1\" type=\"RichFloat\" tooltip=\"Radius of the bottom circumference\"/>
        <Param name=\"r1\" description=\"Radius 2\" value=\"$radius2\" type=\"RichFloat\" tooltip=\"Radius of the top circumference\"/>
        <Param name=\"h\" description=\"Height\" value=\"$height\" type=\"RichFloat\" tooltip=\"Height of the Cone\"/>
        <Param name=\"subdiv\" description=\"Side\" value=\"$fn\" type=\"RichInt\" tooltip=\"Number of sides of the polygonal approximation of the cone\"/>
    </filter>" >> "$ml_SF"
    if [ "$center" != "true" ]; then
        mlx_translate y=$(bc <<< "scale=10;($height/2)")
    fi
    if [ "$m_up" = "Z" ]; then
        mlx_rotate x=90 # rotate to Z up
    fi
    if [ -n "$color" ]; then
        mlx_color_V color="$color"
    fi
}

# Usage: radius=(1) subdiv=(3)
mlx_sphere() {
    # Options & Defaults
    local radius=1
    local subdiv=3 # Subdivision level; Number of the recursive subdivision of the surface. Default is 3 (a sphere approximation composed by 1280 faces). Admitted values are in the range 0 (an icosahedron) to 8 (a 1.3 MegaTris approximation of a sphere). Formula for number of faces: F=20*4^subdiv
    local color="" # specify a color name to apply vertex colors to the newly created mesh
    
    # Other
    local i
    
    for i in "$@"; do
        case $i in
            r=*|radius=*|rad=*)
                radius="${i#*=}"
                shift # past argument=value
                ;;
            subdiv=*)
                subdiv="${i#*=}"
                shift # past argument=value
                ;;
            color=*)
                color="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done
    
    echo "\
    <filter name=\"Sphere\">
        <Param name=\"radius\" description=\"Radius\" value=\"$radius\" type=\"RichFloat\" tooltip=\"Radius of the sphere\"/>
        <Param name=\"subdiv\" description=\"Subdiv. Level\" value=\"$subdiv\" type=\"RichInt\" tooltip=\"Number of the recursive subdivision of the surface. Default is 3 (a sphere approximation composed by 1280 faces).&lt;br>Admitted values are in the range 0 (an icosahedron) to 8 (a 1.3 MegaTris approximation of a sphere)\"/>
    </filter>" >> "$ml_SF"
    if [ -n "$color" ]; then
        mlx_color_V color="$color"
    fi
}

# Usage: angle=(60) subdiv=(3)
mlx_sphere_cap() {
    # Options & Defaults
    local angle=60 # Angle of the cone subtending the cap. It must be <180
    local subdiv=3 # Subdivision level; Number of the recursive subdivision of the surface. Default is 3 (a sphere approximation composed by 1280 faces). Admitted values are in the range 0 (an icosahedron) to 8 (a 1.3 MegaTris approximation of a sphere). Formula for number of faces: F=20*4^subdiv
    local color="" # specify a color name to apply vertex colors to the newly created mesh
    
    # Other
    local i
    
    for i in "$@"; do
        case $i in
            a=*|angle=*)
                angle="${i#*=}"
                shift # past argument=value
                ;;
            subdiv=*)
                subdiv="${i#*=}"
                shift # past argument=value
                ;;
            color=*)
                color="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done

    echo "\
    <filter name=\"Sphere Cap\">
        <Param name=\"angle\" description=\"Angle\" value=\"$angle\" type=\"RichFloat\" tooltip=\"Angle of the cone subtending the cap. It must be &lt; 180\"/>
        <Param name=\"subdiv\" description=\"Subdiv. Level\" value=\"$subdiv\" type=\"RichInt\" tooltip=\"Number of the recursive subdivision of the surface. Default is 3 (a sphere approximation composed by 1280 faces).&lt;br>Admitted values are in the range 0 (an icosahedron) to 8 (a 1.3 MegaTris approximation of a sphere)\"/>
    </filter>" >> "$ml_SF"
    if [ -n "$color" ]; then
        mlx_color_V color="$color"
    fi
}

# Usage: (radius_h= radius_v= )|(ID= OD= ) fn_h= fn_v=
mlx_torus() {
    # Options & Defaults
    local radius_h=3 # Radius of the whole horizontal ring of the torus
    local radius_v=1 # Radius of the vertical section of the ring
    local ID # Alt; inner diameter of torus, ID=2*(radius_h-radius_v)
    local OD # Alt; outer diameter of torus, OD=2*(radius_h+radius_v)
    local fn_h=24 # Subdivision step of the ring
    local fn_v=12 # Number of sides of the polygonal approximation of the torus section
    local color="" # specify a color name to apply vertex colors to the newly created mesh
    
    # Other
    local i
    
    # If fn is set globally use that as default
    if [ -n "$fn" ]; then
        fn_h="$fn"
        fn_v="$fn"
    fi

    for i in "$@"; do
        case $i in
            rh=*|radius_h=*|rad_h=*)
                radius_h="${i#*=}"
                shift # past argument=value
                ;;
            rv=*|radius_v=*|rad_v=*)
                radius_v="${i#*=}"
                shift # past argument=value
                ;;
            ID=*|inner[dD]iameter=*)
                ID="${i#*=}"
                if [ -n "$OD" ]; then
                    #radius_h=($ID+$OD)/4
                    radius_h=$(bc <<< "scale=10;(($ID+$OD)/4)")
                    #radius_v=$radius_h-$ID/2
                    radius_v=$(bc <<< "scale=10;($radius_h-$ID/2)")
                fi            
                shift # past argument=value
                ;;
            OD=*|outer[dD]iameter=*)
                OD="${i#*=}"
                if [ -n "$ID" ]; then
                    #radius_h=($ID+$OD)/4
                    radius_h=$(bc <<< "scale=10;(($ID+$OD)/4)")
                    #radius_v=$radius_h-$ID/2
                    radius_v=$(bc <<< "scale=10;($radius_h-$ID/2)")
                fi 
                shift # past argument=value
                ;;
            fn_h=*)
                fn_h="${i#*=}"
                shift # past argument=value
                ;;
            fn_v=*)
                fn_v="${i#*=}"
                shift # past argument=value
                ;;
            color=*)
                color="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done

    echo "\
    <filter name=\"Torus\">
        <Param name=\"hRadius\" description=\"Horizontal Radius\" value=\"$radius_h\" type=\"RichFloat\" tooltip=\"Radius of the whole horizontal ring of the torus\"/>
        <Param name=\"vRadius\" description=\"Vertical Radius\" value=\"$radius_v\" type=\"RichFloat\" tooltip=\"Radius of the vertical section of the ring\"/>
        <Param name=\"hSubdiv\" description=\"Horizontal Subdivision\" value=\"$fn_h\" type=\"RichInt\" tooltip=\"Subdivision step of the ring\"/>
        <Param name=\"vSubdiv\" description=\"Vertical Subdivision\" value=\"$fn_v\" type=\"RichInt\" tooltip=\"Number of sides of the polygonal approximation of the torus section\"/>
    </filter>" >> "$ml_SF"
    if [ -n "$color" ]; then
        mlx_color_V color="$color"
    fi
}

# Usage: size=(1)|(X=(1) Y=(1)) center=(false)
# 2D square/plane/grid created on XY plane
mlx_square() { # 2D
    # Options & Defaults
    local sizeX=1
    local sizeY=1
    local num_V_X=2 # Number of vertices in the X direction. Must be at least 2 (start and end vertices); setting this to a higher value will create an evenly spaced grid.
    local num_V_Y=2 # Number of vertices in the Y direction. Must be at least 2 (start and end vertices); setting this to a higher value will create an evenly spaced grid.
    local center="false" # If true square will be centered on origin; otherwise it is place in the positive XY quadrant. Note that the "center" parameter in the mlx script does not actually center the square, not sure what it is doing. Instead this is set to false, which places the plane in the -X,+Y quadrant, and it is translated to the appropriate position after creation.
    local color="" # specify a color name to apply vertex colors to the newly created mesh
    
    # Other
    local i
    
    for i in "$@"; do
        case $i in
            s=*|size=*)
                sizeX="${i#*=}"
                sizeY="${i#*=}"
                shift # past argument=value
                ;;
            [xX]=*)
                sizeX="${i#*=}"
                shift # past argument=value
                ;;
            [yY]=*)
                sizeY="${i#*=}"
                shift # past argument=value
                ;;
            c=*|center=*)
                center="${i#*=}"
                shift # past argument=value
                ;;
            color=*)
                color="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done
    
    echo "\
    <filter name=\"Grid Generator\">
        <Param name=\"numVertX\" description=\"num vertices on x\" value=\"$num_V_X\" type=\"RichInt\" tooltip=\"number of vertices on x. it must be positive\"/>
        <Param name=\"numVertY\" description=\"num vertices on y\" value=\"$num_V_Y\" type=\"RichInt\" tooltip=\"number of vertices on y. it must be positive\"/>
        <Param name=\"absScaleX\" description=\"x scale\" value=\"$sizeX\" type=\"RichFloat\" tooltip=\"absolute scale on x (float)\"/>
        <Param name=\"absScaleY\" description=\"y scale\" value=\"$sizeY\" type=\"RichFloat\" tooltip=\"absolute scale on y (float)\"/>
        <Param name=\"center\" description=\"centered on origin\" value=\"false\" type=\"RichBool\" tooltip=\"center grid generated by filter on origin.&lt;br>Grid is first generated and than moved into origin (using muparser lib to perform fast calc on every vertex)\"/>
    </filter>" >> "$ml_SF"
    
    if [ "$center" = "true" ]; then
        mlx_translate x=$(bc <<< "scale=10;($sizeX/2)") y=$(bc <<< "scale=10;(-$sizeY/2)")        
    else
        mlx_translate x="$sizeX"
    fi
    if [ -n "$color" ]; then
        mlx_color_V color="$color"
    fi
}

# Usage: (radius=(1)|(radius1=(1) radius2=(0)))|(diameter=(2)|(diameter1=(2) diameter2=(0)))
#2D annulus
mlx_circle() { #2D
    # Options & Defaults
    local radius1=1 # Outer radius of the circle
    local radius2=0 # Inner radius of the circle (if non-zero it creates an annulus)
    local color="" # specify a color name to apply vertex colors to the newly created mesh
    
    # Other
    local i
    
    # If fn is set globally use that as default
    if [ -z "$fn" ]; then fn="32"; fi
    
    for i in "$@"; do
        case $i in
            r=*|radius=*|rad=*|r1=*|radius1=*|rad1=*)
                radius1="${i#*=}"
                shift # past argument=value
                ;;
            r2=*|radius2=*)
                radius2="${i#*=}"
                shift # past argument=value
                ;;
            d=*|diameter=*|dia=*|d1=*|diameter1=*|dia1=*)
                radius1=$(bc <<< "scale=10;(${i#*=} / 2)")
                shift # past argument=value
                ;;
            d2=*|diameter2=*|dia2=*)
                radius2=$(bc <<< "scale=10;(${i#*=} / 2)")
                shift # past argument=value
                ;;
            fn=*)
                fn="${i#*=}"
                shift # past argument=value
                ;;
            color=*)
                color="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done
    
    # Annulus is created centered on the XY plane
    
    echo "\
    <filter name=\"Annulus\">
        <Param name=\"internalRadius\" description=\"Internal Radius\"value=\"$radius2\" type=\"RichFloat\"  tooltip=\"Internal Radius of the annulus\"/>
        <Param name=\"externalRadius\" description=\"External Radius\" value=\"$radius1\" type=\"RichFloat\" tooltip=\"External Radius of the annulus\"/>
        <Param name=\"sides\" description=\"Sides\" value=\"$fn\" type=\"RichInt\" tooltip=\"Number of the sides of the poligonal approximation of the annulus\"/>
    </filter>" >> "$ml_SF"
    if [ -n "$color" ]; then
        mlx_color_V color="$color"
    fi
}

### End Create ###


### Begin Sampling ###

mlx_hausdorff_distance() {
    # Options & Defaults
    local sampledLayer=1 # The mesh whose surface is sampled. For each sample we search the closest point on the Target Mesh.
    local targetLayer=0 # The mesh that is sampled for the comparison.
    local saveSample="false" # Save the position and distance of all the used samples on both the two surfaces, creating two new layers with two point clouds representing the used samples.
    local sample_V="true" # For the search of maxima it is useful to sample vertices and edges of the mesh with a greater care. It is quite probable that the farthest points falls along edges or on mesh vertexes, and with uniform montecarlo sampling approaches the probability of taking a sample over a vertex or an edge is theoretically null. On the other hand this kind of sampling could make the overall sampling distribution slightly biased and slightly affects the cumulative results.
    local sample_E="true" # See the above comment.
    local sample_fauxE="false" # See the above comment.
    local sample_F="true" # See the above comment.
    local sample_num=1000 # The desired number of samples. It can be smaller or larger than the mesh size, and according to the chosen sampling strategy it will try to adapt. ML default: number of vertices in sampled mesh
    local maxdist=10 # Sample points for which we do not find anything within this distance are rejected and not considered neither for averaging nor for max. ML default: 5% AABB[diag] of sampled mesh, max 100% AABB[diag] of sampled mesh
    
    # Other
    local i
    local maxdistmax=100
    # num_V will be used to set sample_num if available
    if [ -n "$num_V" ]; then
        sample_num=$num_V
    fi
    # AABB[diag] will be used to set maxes and mins if available
    if [ -n "${AABB[diag]}" ]; then
        maxdist=$(bc <<< "0.05 * ${AABB[diag]}") #5% of AABB[diag]
        maxdistmax="${AABB[diag]}"
    fi
    
    for i in "$@"; do
        case $i in
            sampled[lL]ayer=*)
                sampledLayer="${i#*=}"
                shift # past argument=value
                ;;
            target[lL]ayer=*)
                targetLayer="${i#*=}"
                shift # past argument=value
                ;;
            save[sS]ample=*|save=*)
                saveSample="${i#*=}"
                shift # past argument=value
                ;;
            sample_V=*)
                sample_V="${i#*=}"
                shift # past argument=value
                ;;
            sample_E=*)
                sample_E="${i#*=}"
                shift # past argument=value
                ;;
            sample_fauxE=*)
                sample_fauxE="${i#*=}"
                shift # past argument=value
                ;;
            sample_F=*)
                sample_F="${i#*=}"
                shift # past argument=value
                ;;
            sample_num=*)
                sample_num="${i#*=}"
                shift # past argument=value
                ;;
            maxdist=*)
                maxdist="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done
    
    echo "\
    <filter name=\"Hausdorff Distance\">
        <Param name=\"SampledMesh\" description=\"Sampled Mesh\" value=\"$sampledLayer\" type=\"RichMesh\" tooltip=\"The mesh whose surface is sampled. For each sample we search the closest point on the Target Mesh.\"/>
        <Param name=\"TargetMesh\" description=\"Target Mesh\" value=\"$targetLayer\" type=\"RichMesh\" tooltip=\"The mesh that is sampled for the comparison.\"/>
        <Param name=\"SaveSample\" description=\"Save Samples\" value=\"$saveSample\" type=\"RichBool\" tooltip=\"Save the position and distance of all the used samples on both the two surfaces, creating two new layers with two point clouds representing the used samples.\"/>
        <Param name=\"SampleVert\" description=\"Sample Vertexes\" value=\"$sample_V\" type=\"RichBool\" tooltip=\"For the search of maxima it is useful to sample vertices and edges of the mesh with a greater care. It is quite probably the the farthest points falls along edges or on mesh vertexes, and with uniform montecarlo sampling approachesthe probability of taking a sample over a vertex or an edge is theoretically null.&lt;br>On the other hand this kind of sampling could make the overall sampling distribution slightly biased and slightly affects the cumulative results.\"/>
        <Param name=\"SampleEdge\" description=\"Sample Edges\" value=\"$sample_E\" type=\"RichBool\" tooltip=\"See the above comment.\"/>
        <Param name=\"SampleFauxEdge\" description=\"Sample FauxEdge\" value=\"$sample_fauxE\" type=\"RichBool\" tooltip=\"See the above comment.\"/>
        <Param name=\"SampleFace\" description=\"Sample Faces\" value=\"$sample_F\" type=\"RichBool\" tooltip=\"See the above comment.\"/>
        <Param name=\"SampleNum\" description=\"Number of samples\" value=\"$sample_num\" type=\"RichInt\" tooltip=\"The desired number of samples. It can be smaller or larger than the mesh size, and according to the choosed sampling strategy it will try to adapt.\"/>
        <Param name=\"MaxDist\" description=\"Max Distance\" value=\"$maxdist\" min=\"0\" max=\"$maxdistmax\" type=\"RichAbsPerc\" tooltip=\"Sample points for which we do not find anything whithin this distance are rejected and not considered neither for averaging nor for max.\"/>
    </filter>" >> "$ml_SF"
}

mlx_sampling() {
    # Options & Defaults
    local method="poisson_disk" # Method to use; currently only Poisson-disk is implemented but others (Montecarlo, etc.) may be added later
    local sample_num=1000 # The desired number of samples. The ray of the disk is calculated according to the sampling density.
    local radius=0 # If not zero this parameter override the previous parameter to allow exact radius specification, max=AABB[diag]
    local montecarloRate=20 # The over-sampling rate that is used to generate the intial Montecarlo samples (e.g. if this parameter is &lt;i>K&lt;/i> means that&lt;i>K&lt;/i> x &lt;i>poisson sample&lt;/i> points will be used). The generated Poisson-disk samples are a subset of these initial Montecarlo samples. Larger this number slows the process but make it a bit more accurate.
    local saveMontecarlo="false" # If true, it will generate an additional Layer with the montecarlo sampling that was pruned to build the poisson distribution.
    local approxGeodesicDist="false" # If true Poisson Disc distances are computed using an approximate geodesic distance, e.g. an euclidean distance weighted by a function of the difference between the normals of the two points.
    local subsample="false" # If true the original vertices of the base mesh are used as base set of points. In this case the SampleNum should be obviously much smaller than the original vertex number.&lt;br>Note that this option is very useful in the case you want to subsample a dense point cloud.
    local refine="false" # If true the vertices of the below mesh are used as starting vertices, and they will utterly refined by adding more and more points until possible.
    local refineMesh=0 # Used only if the above option is checked.
    local bestSample="true" # If true it will use a simple heuristic for choosing the samples. At a small cost (it can slow a bit the process) it usually improve the maximality of the generated sampling.
    local bestSamplePool=10 # Used only if the Best Sample Flag is true. It control the number of attempt that it makes to get the best sample. It is reasonable that it is smaller than the Montecarlo oversampling factor.
    local exactNum="false" # If requested it will try to do a dicotomic search for the best poisson disk radius that will generate the requested number of samples with a tolerance of the 0.5%. Obviously it takes much longer.
    local radiusVariance=1 # The radius of the disk is allowed to vary between r and r*var. If this parameter is 1 the sampling is the same of the Poisson Disk Sampling.
    
    # Other
    local i
    
    for i in "$@"; do
        case $i in
            sample_num=*)
                sample_num="${i#*=}"
                shift # past argument=value
                ;;
            r=*|radius=*)
                radius="${i#*=}"
                shift # past argument=value
                ;;
            montecarlo[rR]ate=*)
                montecarloRate="${i#*=}"
                shift # past argument=value
                ;;
            save[mM]ontecarlo=*)
                saveMontecarlo="${i#*=}"
                shift # past argument=value
                ;;
            approx[gG]eodesic[dD]ist=*)
                approxGeodesicDist="${i#*=}"
                shift # past argument=value
                ;;
            subsample=*)
                subsample="${i#*=}"
                shift # past argument=value
                ;;
            refine=*)
                refine="${i#*=}"
                shift # past argument=value
                ;;
            refineMesh=*)
                refineMesh="${i#*=}"
                shift # past argument=value
                ;;
            best[sS]ample[pP]ool=*)
                bestSamplePool="${i#*=}"
                shift # past argument=value
                ;;
            exact[nN]um=*)
                exactNum="${i#*=}"
                shift # past argument=value
                ;;
            radius[vV]ariance=*)
                radiusVariance="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done
    
    echo "\
    <filter name=\"Poisson-disk Sampling\">
        <Param name=\"SampleNum\" description=\"Number of samples\" value=\"$sample_num\" type=\"RichInt\" tooltip=\"The desired number of samples. The ray of the disk is calculated according to the sampling density.\"/>
        <Param name=\"Radius\" description=\"Explicit Radius\" value=\"$radius\" min=\"0\" max=\"100\" type=\"RichAbsPerc\" tooltip=\"If not zero this parameter override the previous parameter to allow exact radius specification\"/>
        <Param name=\"MontecarloRate\" description=\"MonterCarlo OverSampling\" value=\"$montecarloRate\" type=\"RichInt\" tooltip=\"The over-sampling rate that is used to generate the intial Montecarlo samples (e.g. if this parameter is &lt;i>K&lt;/i> means that&lt;i>K&lt;/i> x &lt;i>poisson sample&lt;/i> points will be used). The generated Poisson-disk samples are a subset of these initial Montecarlo samples. Larger this number slows the process but make it a bit more accurate.\"/>
        <Param name=\"SaveMontecarlo\" description=\"Save Montecarlo\" value=\"$saveMontecarlo\" type=\"RichBool\" tooltip=\"If true, it will generate an additional Layer with the montecarlo sampling that was pruned to build the poisson distribution.\"/>
        <Param name=\"ApproximateGeodesicDistance\" description=\"Approximate Geodesic Distance\" value=\"$approxGeodesicDist\" type=\"RichBool\" tooltip=\"If true Poisson Disc distances are computed using an approximate geodesic distance, e.g. an euclidean distance weighted by a function of the difference between the normals of the two points.\"/>
        <Param name=\"Subsample\" description=\"Base Mesh Subsampling\" value=\"$subsample\" type=\"RichBool\" tooltip=\"If true the original vertices of the base mesh are used as base set of points. In this case the SampleNum should be obviously much smaller than the original vertex number.&lt;br>Note that this option is very useful in the case you want to subsample a dense point cloud.\"/>
        <Param name=\"RefineFlag\" description=\"Refine Existing Samples\" value=\"$refine\" type=\"RichBool\" tooltip=\"If true the vertices of the below mesh are used as starting vertices, and they will utterly refined by adding more and more points until possible. \"/>
        <Param name=\"RefineMesh\" description=\"Samples to be refined\" value=\"$refineMesh\" type=\"RichMesh\" tooltip=\"Used only if the above option is checked. \"/>
        <Param name=\"BestSampleFlag\" description=\"Best Sample Heuristic\" value=\"$bestSample\" type=\"RichBool\" tooltip=\"If true it will use a simple heuristic for choosing the samples. At a small cost (it can slow a bit the process) it usually improve the maximality of the generated sampling. \"/>
        <Param name=\"BestSamplePool\" description=\"Best Sample Pool Size\" value=\"$bestSamplePool\" type=\"RichInt\" tooltip=\"Used only if the Best Sample Flag is true. It control the number of attempt that it makes to get the best sample. It is reasonable that it is smaller than the Montecarlo oversampling factor.\"/>
        <Param name=\"ExactNumFlag\" description=\"Exact number of samples\" value=\"$exactNum\" type=\"RichBool\" tooltip=\"If requested it will try to do a dicotomic search for the best poisson disk radius that will generate the requested number of samples with a tolerance of the 0.5%. Obviously it takes much longer.\"/>
        <Param name=\"RadiusVariance\" description=\"Radius Variance\" value=\"$radiusVariance\" type=\"RichFloat\" tooltip=\"The radius of the disk is allowed to vary between r and r*var. If this parameter is 1 the sampling is the same of the Poisson Disk Sampling\"/>
    </filter>" >> "$ml_SF"
}

### End Sampling ###


### Begin Color ###

# TODO: test out using a function
# It's possible to use the following per-vertex variables in the expression: x, y, z, nx, ny, nz (normal), r, g, b (color), q (quality), rad, vi (index), vtu, vtv (tex coord) and all custom vertex attributes already defined by user.
mlx_color_V() {
    # Options & Defaults
    local r=0 # Function to generate Red component. Expected Range 0-255
    local g=0 # Function to generate Green component. Expected Range 0-255
    local b=0 # Function to generate Blue component. Expected Range 0-255
    local a=255 # Function to generate Alpha component. Expected Range 0-255
    
    # Other
    local i
    local color
    local color_name
    
    for i in "$@"; do
        case $i in
            [rR]=*|red=*)
                r="${i#*=}"
                shift # past argument=value
                ;;
            [gG]=*|green=*)
                g="${i#*=}"
                shift # past argument=value
                ;;
            [bB]=*|blue=*)
                b="${i#*=}"
                shift # past argument=value
                ;;
            [aA]=*|alpha=*)
                a="${i#*=}"
                shift # past argument=value
                ;;
            color=*)
                color="${i#*=}"
                color_name=$(grep -w "$color" "${scriptpath}/color_names.txt")
                if [ -z "$color_name" ]; then
                    echo "Color \"$color\" not found, not setting any color"
                    return 1
                fi
                r=$(echo "$color_name" | cut -d" " -f3)
                g=$(echo "$color_name" | cut -d" " -f4)
                b=$(echo "$color_name" | cut -d" " -f5)
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done
    
    echo "\
    <filter name=\"Per Vertex Color Function\">
        <Param name=\"x\" description=\"func r = \" value=\"$r\" type=\"RichString\" tooltip=\"function to generate Red component. Expected Range 0-255\"/>
        <Param name=\"y\" description=\"func g = \" value=\"$g\" type=\"RichString\" tooltip=\"function to generate Green component. Expected Range 0-255\"/>
        <Param name=\"z\" description=\"func b = \" value=\"$b\" type=\"RichString\" tooltip=\"function to generate Blue component. Expected Range 0-255\"/>
        <Param name=\"a\" description=\"func alpha = \" value=\"$a\" type=\"RichString\" tooltip=\"function to generate Alpha component. Expected Range 0-255\"/>
    </filter>" >> "$ml_SF"
}

mlx_voronoi_V_color() {
    # Options & Defaults
    local target=0 # The mesh whose surface is colored. For each vertex of this mesh we decide the color according the below parameters.
    local source=1 # The mesh whose vertexes are used as seed points for the color computation. These seeds point are projected onto the target mesh.
    local backward="true" # If true the mesh is colored according the distance from the frontier of the voronoi diagram induced by the source mesh seeds.
    
    # Other
    local i
    
    for i in "$@"; do
        case $i in
            target=*)
                target="${i#*=}"
                shift # past argument=value
                ;;
            source=*)
                source="${i#*=}"
                shift # past argument=value
                ;;
            backward=*)
                b="${i#*=}"
                shift # past argument=value
                ;;
            *)
                # unknown option
                ;;
        esac
    done
    
    echo "\
    <filter name=\"Voronoi Vertex Coloring\">
        <Param name=\"ColoredMesh\" description=\"To be Colored Mesh\" value=\"$target\" type=\"RichMesh\" tooltip=\"The mesh whose surface is colored. For each vertex of this mesh we decide the color according the below parameters.\"/>
        <Param name=\"VertexMesh\" description=\"Vertex Mesh\" value=\"$source\" type=\"RichMesh\" tooltip=\"The mesh whose vertexes are used as seed points for the color computation. These seeds point are projected onto the above mesh.\"/>
        <Param name=\"backward\" description=\"BackDistance\" value=\"$backward\" type=\"RichBool\" tooltip=\"If true the mesh is colored according the distance from the frontier of the voronoi diagram induced by the VertexMesh seeds.\"/>
    </filter>" >> "$ml_SF"
}

### End Color ###


### Begin Utility Functions ###

isnumber() {
    # Function to determine if a variable is a number or a string
    
    # Old way; this fails for "0"
    # regexp='^[-|+|0-9|.][.0-9]*$'
    # if expr match "$1" "\($regexp\)" &> /dev/null; then
        # return 0
    # else
        # return 1
    # fi
    
    local test
    test=$(awk -v a="$1" 'BEGIN {print (a == a + 0)}')
    # The function will return "1" if the argument is a number, otherwise will return "0". This works for integers, floats & scientific notation at least.
    if [ "$test" -eq 1 ]; then
        return 0
    else
        return 1
    fi
}

trim() {
    # trim leading & trailing whitespace from variable
    # from http://stackoverflow.com/questions/369758/how-to-trim-whitespace-from-bash-variable
    local var="$*"
    var="${var#"${var%%[![:space:]]*}"}"   # remove leading whitespace characters
    var="${var%"${var##*[![:space:]]}"}"   # remove trailing whitespace characters
    echo -n "$var"
}

cconv() {
    # Currency converter
    # Source: http://www.linux-magazine.com/Online/Blogs/Productivity-Sauce/Simple-Bash-Currency-Converter
    # usage: cconv amt source target, e.g. cconv 11 eur usd
    #  wget -qO- "http://www.google.com/finance/converter?a=$1&from=$2&to=$3" |  sed '/res/!d;s/<[^>]*>//g';
    cconv_temp_file="TEMP_cconv.txt"
    wget -qO- "http://www.google.com/finance/converter?a=$1&from=$2&to=$3" &> "$cconv_temp_file"
    cat "$cconv_temp_file" | sed '/res/!d;s/<[^>]*>//g' | cut -d" " -f4
    rm -f "$cconv_temp_file"
}

silent() {
    # function to direct output to /dev/null to silence output
    if [ "$verbosity" -ge 5 ]; then
        "$@"
    else
        "$@" &>/dev/null
    fi
}

pause() {
    # $1 = message string
    if [ -z "$1" ]; then
        message="Paused, hit any key to continue ... "
    else
        message="$1"
    fi
	echo
	read -rsp "$message" -n1 key
}

### End Utility Functions ###
