#########################################################################
#
# polylinesort - polylinesort.c converted to this bash script
# License: LGPLv2.1
#
#########################################################################

#
# boolean variables
#
true=1
false=0
polyline_started=$false
tail_found=$false
closed_polyline=$false

#
# integer variables
#
num_vertices=0
num_linesets=0
num_polylines=0
next_point=0
start_point=0
sort_cnt=0
line_cnt=0
loop_cnt=0

#
# array variables
#
# Vx[] Vy[] Vz[]  - vertice "v" points x, y, and z
# Lp1[] Lp2[]     - line set "l" points p1 and p2
# sorted_points[] - sorted polyline points

######################################
#
# write polyline output function
#
######################################
write_polyline()
  {
  # output file name
  filename="polyline_$num_polylines.xyz"

  if (($closed_polyline)); then
    printf "Polyline $num_polylines is a closed polyline set of $sort_cnt points \n"
  else
    printf "Polyline $num_polylines is an open polyline set of $sort_cnt points \n"
  fi

  # print the sorted line sets
  j=1
  k=0
  while ((j < $sort_cnt)); do
    printf "${sorted_points[$k]} ${sorted_points[$j]} \n"
    ((j++))
    ((k++))
  done
  if (($closed_polyline)); then
    printf "${sorted_points[$k]} ${sorted_points[0]} \n"
  fi

  # write the sorted vertice points
  printf "Writing sorted vertice points xyz to $filename \n"
  rm -f $filename
  j=0
  while ((j < $sort_cnt)); do
    ((temp_point = ${sorted_points[$j]} - 1))
    printf "%f %f %f \n" ${Vx[$temp_point]} ${Vy[$temp_point]} ${Vz[$temp_point]}
    printf "%f %f %f \n" ${Vx[$temp_point]} ${Vy[$temp_point]} ${Vz[$temp_point]} >> $filename
    ((j++))
  done
  }

############################################
#                                          #
#   Start of Main Porgram                  #
#                                          #
############################################

  #  make sure there's an input filename passed
  if [ $# -lt 1 ]; then
    printf "\nInput filename argument is missing\n"
    exit 1
  fi

  # read the vertices and line sets
  if  [ -f "$1" ]; then
    printf "Reading vertices and line sets from input file $1 \n"
  else
    printf "\nInput file $1 not found\n"
    exit 2
  fi

  while read type arg1 arg2 arg3; do
    if [ "$type" = "v" ]; then
      Vx[$num_vertices]=$arg1
      Vy[$num_vertices]=$arg2
      Vz[$num_vertices]=$arg3
      ((num_vertices++))
    fi
    if [ "$type" = "l" ]; then
      Lp1[$num_linesets]=$arg1
      Lp2[$num_linesets]=$arg2
      ((num_linesets++))
    fi
  done < $1

  printf "vertices $num_vertices line sets $num_linesets \n"

  # need at least 2 vertices and 1 line set in the input file
  if (($num_vertices < 2 || $num_linesets == 0)); then
    printf "Error: number of vertices < 2 or number line sets = 0\n"
    exit 3
  fi

  printf "Sorting line set points \n"

#****************************************************************************************
# Process each input line set 1 to n until all the points in the line set are sorted
# into 1 or more polyline sets of continuous points. The polyline sets can be either
# and open polyline or a closed polyine defining a polygon.
#
# These are the possible cases for the current input line set of points being processed and
# any previous line set points that were already processed:
#
# 1. If line set p1 is zero these points in have already been processed so skip line.
#
# 2. If a polyline has not been started then p1 is set to the start point of the new polyline.
#    The second point p2 is the next point in the polyline and is also the next point
#    to look for in the remaining line set points.
#
# 3. Either p1 or p2 is the next point and the other point is not the start point.
#    Save the other point and set it to the next point to find.
#
# 4. Either p1 or p2 is the next point and the other point is the start point.
#    This indicates that the polyline is closed (polygon).
#
#    Note: If any line sets are remaining then continue processing them as
#          a new polyline.
#
# 5. The next point was not found in the remaining line set points so it's an open polyline.
#    If the tail has already been found then the last sorted point is the head and
#    the polyline is finished. Otherwise the last sorted point is the tail and the next
#    point to find is the saved start point towards the head of the polyline.
#
#*************************************************************************

  # loop until all the points in line sets have been sorted
  while (($line_cnt < $num_linesets)); do

    i=0
    loop_cnt=0

    # process next line set
    while (($i < $num_linesets)); do

      # skip line set points if already used
      if ((${Lp1[$i]} == 0)); then
        ((i++))
        continue
      fi

      # start new polyline
      if ((!$polyline_started)); then

        polyline_started=$true
        tail_found=$false
        ((num_polylines++))

        # save the first 2 line points
        sorted_points[0]=${Lp1[$i]}
        sorted_points[1]=${Lp2[$i]}
        sort_cnt=2

        # save the starting point and set the next point to find
        start_point=${Lp1[$i]}
        next_point=${Lp2[$i]}

        # set points in the line set to 0 to eliminate them from remaining line sets
        Lp1[$i]=0
        Lp2[$i]=0
        ((line_cnt++))
        break
      fi

      # found next point and other point is not start point
      if ((${Lp1[$i]} == next_point && ${Lp2[$i]} != start_point ||
           ${Lp2[$i]} == next_point && ${Lp1[$i]} != start_point)); then

        if ((${Lp1[$i]} == next_point)); then
          sorted_points[$sort_cnt]=${Lp2[$i]}
          ((sort_cnt++))
          next_point=${Lp2[$i]}
        else
          sorted_points[$sort_cnt]=${Lp1[$i]}
          ((sort_cnt++))
          next_point=${Lp1[$i]}
        fi
        Lp1[$i]=0
        Lp2[$i]=0
        ((line_cnt++))
        break
      fi

      # found next point and other point is start point, closed polyline
      # write the polyline output
      if ((${Lp1[$i]} == next_point && ${Lp2[$i]} == start_point ||
           ${Lp2[$i]} == next_point && ${Lp1[$i]} == start_point)); then

        closed_polyline=$true
        write_polyline
        polyline_started=$false
        Lp1[$i]=0
        Lp2[$i]=0
        ((line_cnt++))
        break
      fi
      ((i++))

      # next point was not found in remaining line sets
      if (($i == $num_linesets)); then
        loop_cnt=1
      fi
    done

    # if polyline started and next point not found
    if (($polyline_started && $loop_cnt == 1)); then

      # if tail already found we're at the head of the polyline
      # write the polyline output
      if (($tail_found)); then
        closed_polyline=$false
        write_polyline
        polyline_started=$false
        continue
      else
        # tail of an open polyline, set next point to look for head in remaining line sets
        tail_found=$true
        next_point=$start_point
        start_point=${sorted_points[$sort_cnt - 1]}

        # reorder the sorted points so tail is the first point
        i=0
        ((j = $sort_cnt - 1))
        while ((j > i)); do
          temp_point=${sorted_points[$i]}
          sorted_points[$i]=${sorted_points[$j]}
          sorted_points[$j]=$temp_point
          ((i++))
          ((j--))
        done
        continue
      fi
    fi
  done  # end of line sets to process

  # if a polyline was started and end of line sets
  # write the polyline output
  if (($polyline_started)); then
    closed_polyline=$false
    write_polyline
  fi

  printf "End of line sets \n"
  exit 0

