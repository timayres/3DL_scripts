#!/bin/bash
#mlx.bsh
#version=.1
#functions and variables for running MeshLab and mlx scripts
# filters are based on MeshLab v 1.3.4BETA for 64 bit Windows
#License:

# REF: test if empty or not:
# -z true if string is zero
# -n true if string is non-zero
# -e true if file exists
# -s true if file exists and size is greater than zero

# TODO: identify which filters cause a new layer to be created, and what that new layer name is

# TODO: add some error checking of input

# TODO: write script to split model into individual components
# could use sel_small_components with .99, then invert select to delete the largest object, & iterate.
# 1-delete small components to get largest volume; save
# 2-select small components, invert sel & del largest component. Go to 1.


###Initialize variables for run_meshlab
ml_OF="" #output filename
ml_SF="" #filename for .mlx filter script
ml_LF="" #filename for ML log
run_meshlab() {
    ##Function to run meshlabserver
    ##Variables (set before calling):
    # ml_IF
    # ml_OF
    # ml_SF (run mlx script, not needed e.g. just to convert formats)
    # ml_LF (save a log file, mostly useful for cgm & ctm)
    # m_color (for do_om, only needed if ml_OF is not "empty")
    
    # TODO: add support for meshlab project files
    # TODO: add support for multiple input files
    
    local start_time
    local end_time
    local diff_time
    local return_code
    local S
    local L
    local O
    #local om # can set this in calling function to manually override
  
    #set -x
    if [ -z "$ml_SF" ]; then
        S=""
    else
        S="-s $ml_SF"
    fi

    if [ -z "$ml_LF" ]; then
        L=""
    else
        rm -f "$ml_LF" # Remove any existing log file before we write to it
        L="-l $ml_LF"
    fi
    
    if [ -z "$ml_OF" ]; then
        O=""
        om=""
    else
        O="-o $ml_OF"
        if [ -z "$om" ]; then
            #if [ -z "$m_color" ]; then
            #    set_m_color "$ml_IF"
            #fi
            do_om "${ml_OF##*.}" # set om options based on output extension and m_color
        fi
    fi
    
	echo
	if [ "$verbosity" -ge 5 ]; then
		echo "*MeshLab*MeshLab*MeshLab*MeshLab*MeshLab*MeshLab*MeshLab*MeshLab*"
	fi
    echo -n "    Running MeshLab ... "
    start_time=$(date +%s.%N)
    silent meshlabserver $L -i "$ml_IF" $O $om $S  # Note: no quotes around options, $L must go first
    return_code=$?
    end_time=$(date +%s.%N)
    diff_time=$(bc <<< "$end_time - $start_time")
    diff_time=$(printf %.0f $diff_time) #round to integer milliseconds
    #echo -n "finished in "; printf "%.2fs\n" $diff_time
    echo -n "finished in "; printf "%0dh:%0dm:%0ds" $(($diff_time/3600)) $(($diff_time%3600/60)) $(($diff_time%60)); echo ", return code: $return_code"
	if [  "$verbosity" -ge 5 ]; then
		echo "*MeshLab*MeshLab*MeshLab*MeshLab*MeshLab*MeshLab*MeshLab*MeshLab*"
	fi
    if [ $return_code -ne 0 ]; then
        pause "Uh oh, looks like there's an error. Hit any key to keep going anyway ... "
    fi
    
    ml_SF=""

    return $return_code
}

# NOTE: this function isn't related to MeshLab in any way, however it is here due to its high degree of similarity with run_meshlab, which makes maintenance easier
run_openscad() {
    #$1=input
    #$2=output
	
	#set -x
    local start_time
    local end_time
    local diff_time
    local return_code
    
    echo ; echo -n "Rendering OpenSCAD file & generating stl ... "
    start_time=$(date +%s.%N)
    openscad -o "$2" "$1"
    return_code=$?
    end_time=$(date +%s.%N)
    diff_time=$(bc <<< "$end_time - $start_time")
    diff_time=$(printf %.0f $diff_time) #round to integer milliseconds
    echo -n "finished in "; printf "%0dh:%0dm:%0ds" $(($diff_time/3600)) $(($diff_time%3600/60)) $(($diff_time%60)); echo ", return code: $return_code"
    
    if [ $return_code -ne 0 ]; then
        pause "Uh oh, looks like there's an error. Hit any key to keep going anyway ... "
    fi
        
    return $return_code
}

do_om () {
    # Function to set MeshLab output mask -m options
    # Usage: the file extension as input to this program
    # Add additional file type support in the future, e.g. ply

    # MeshLab output mask (-m) options:
    # Note: v1.34BETA changed -om switch to -m
    # vc -> vertex colors
    # vf -> vertex flags
    # vq -> vertex quality
    # vn-> vertex normals
    # vt -> vertex texture coords
    # fc -> face colors
    # ff -> face flags
    # fq -> face quality
    # fn-> face normals
    # wc -> wedge colors
    # wn-> wedge normals
    # wt -> wedge texture coords

    if [[ "$ML_VERSION" < "1.3.4" ]]; then
        om_flag="-om"
    else
        om_flag="-m"
    fi
    
    case "$1" in
        [Oo][Bb][Jj] )
            if [ "$m_color" = "UV" ]; then
                om="$om_flag vc vn fc wt" # colored texture
            else
                om="$om_flag vn" # no colors
            fi
            ;;
        [Ss][Tt][Ll] | [Xx][Yy][Zz] | [Dd][Xx][Ff] )
            om="" # no colors or other options
            ;;
        [Xx]3[Dd] )
            om="$om_flag vc vn wt" # textured x3d
            ;;
        * )
            echo "$1 is not currently supported, exiting..."
            exit 1
            ;;
    esac
    return 0
}

mlx_begin() {
    echo "<!DOCTYPE FilterScript>
<FilterScript>" > "$ml_SF"
    case "${ml_IF##*.}" in # check file extension of input
        [Ss][Tt][Ll] )
            mlx_merge_V # Same as "Unify Duplicated Vertices" in MeshLab stl import
            ;;
    esac
}

mlx_end() {
    echo "</FilterScript>" >> "$ml_SF"
}

#example usage
#    ml_SF="TEMP3DP_filter_script.mlx"
#    mlx_begin
#    mlx_scale scale=-10
#    mlx_end


### Begin Measure ###

mlx_measure_geometry () {
    echo "    <xmlfilter name=\"Compute Geometric Measures\"/>" >> "$ml_SF"
}

mlx_measure_topology() {
    echo "    <xmlfilter name=\"Compute Topological Measures\"/>" >> "$ml_SF"
}

# Usage: parse_geometry_log "$ml_LF"
parse_geometry_log() {
    local line_no
    
    # xsize=$(grep "Mesh Bounding Box Size" "$1" | cut -d" " -f5)
    # ysize=$(grep "Mesh Bounding Box Size" "$1" | cut -d" " -f6)
    # zsize=$(grep "Mesh Bounding Box Size" "$1" | cut -d" " -f7)
    volume_mm3=$(grep -m1 "Mesh Volume" "$1" | tr -s " " | cut -d" " -f4)
    volume_cm3=$(bc <<< "scale=10;($volume_mm3 * 0.001)")
    
    area_mm2=$(grep -m1 "Mesh Surface" "$1" | tr -s " " | cut -d" " -f4)
    area_cm2=$(bc <<< "scale=10;($area_mm2 * 0.01)")
    
    total_edge_length=$(grep -m1 "Mesh Total Len of" "$1" | tr -s " " | cut -d" " -f8) # not including faux edges, select -m2 for those
    
    barycenter=( $(grep -m1 "Thin shell barycenter" "$1" | tr -s " " | cut -d" " -f4-6) )
    
    center_of_mass=( $(grep -m1 "Center of Mass" "$1" | tr -s " " | cut -d" " -f5-7) )
    
    # TODO: can I replace the line_no assignments below with inline calls?
    line_no=$(grep -n -m1 "Inertia Tensor" "$1" | cut -d":" -f1)
    line_no=$(($line_no+1))
    inertia_tensor_R0C=( $(awk NR==$line_no "$1" | tr -s " " | cut -d" " -f3-5) )
    line_no=$(($line_no+1))
    inertia_tensor_R1C=( $(awk NR==$line_no "$1" | tr -s " " | cut -d" " -f3-5) )
    line_no=$(($line_no+1))
    inertia_tensor_R2C=( $(awk NR==$line_no "$1" | tr -s " " | cut -d" " -f3-5) )
    
    line_no=$(grep -n -m1 "Principal axes" "$1" | cut -d":" -f1)
    line_no=$(($line_no+1))
    principal_axes_R0C=( $(awk NR==$line_no "$1" | tr -s " " | cut -d" " -f3-5) )
    line_no=$(($line_no+1))
    principal_axes_R1C=( $(awk NR==$line_no "$1" | tr -s " " | cut -d" " -f3-5) )
    line_no=$(($line_no+1))
    principal_axes_R2C=( $(awk NR==$line_no "$1" | tr -s " " | cut -d" " -f3-5) )
    
    line_no=$(grep -n -m1 "axis momenta" "$1" | cut -d":" -f1)
    line_no=$(($line_no+1))
    axis_momenta=( $(awk NR==$line_no "$1" | tr -s " " | cut -d" " -f3-5) )
    
    if [ "$verbosity" -ge 2 ]; then
        echo ; echo "***Parsed Geometry Values***"
        echo -n "  Volume (cm^3): "; printf "%.2f\n" "$volume_cm3"
        #echo -n "  Surface Area (mm^2): "; printf "%.2f\n" "$area_mm2"
        echo -n "  Surface Area (cm^2): "; printf "%.2f\n" "$area_cm2"
        echo -n "  Total Edge Length (mm): "; printf "%.2f\n" "$total_edge_length"
        echo -n "  Thin shell barycenter: "; printf "( %.2f %.2f %.2f )\n" ${barycenter[@]}
        echo -n "  Center of Mass: "; printf "( %.2f %.2f %.2f )\n" ${center_of_mass[@]}
        echo -n "  Inertia Tensor: "; printf "( %.2f %.2f %.2f )\n" ${inertia_tensor_R0C[@]}
        echo -n "                  "; printf "( %.2f %.2f %.2f )\n" ${inertia_tensor_R1C[@]}
        echo -n "                  "; printf "( %.2f %.2f %.2f )\n" ${inertia_tensor_R2C[@]}
        echo -n "  Principal axes: "; printf "( %.2f %.2f %.2f )\n" ${principal_axes_R0C[@]}
        echo -n "                  "; printf "( %.2f %.2f %.2f )\n" ${principal_axes_R1C[@]}
        echo -n "                  "; printf "( %.2f %.2f %.2f )\n" ${principal_axes_R2C[@]}
        echo -n "  Axis momenta: "; printf "( %.2f %.2f %.2f )\n" ${axis_momenta[@]}
        echo "***Parsed Geometry Values***"
    fi
    return 0
}

# Usage: parse_topology_log "$ml_LF"
parse_topology_log() {
    local line_no
    
    num_geometry=$(grep -m1 "V: " "$1")
    num_gemoetry="${num_geometry// /}" # strip all whitespace
    #echo num_gemoetry = "$num_gemoetry"
    num_V=$(echo "$num_gemoetry" | cut -d":" -f2)
    num_V="${num_V%?}" # strip last character
    num_E=$(echo "$num_gemoetry" | cut -d":" -f3)
    num_E="${num_E%?}" # strip last character
    num_F=$(echo "$num_gemoetry" | cut -d":" -f4)

    num_unref_V=$(grep -m1 "Unreferenced Vertices " "$1" | cut -d" " -f3)
    # Filters | Cleaning & Repairing | Remove Unreferenced Vertex
    num_boundry_E=$(grep -m1 "Boundary Edges " "$1" | cut -d" " -f3)
    num_parts=$(grep -m1 "Mesh is composed by " "$1" | cut -d" " -f5)

    manifold=$(grep -m1 "manifold" "$1" | cut -d" " -f3) # two-manifold or non-manifold
    #Mesh is two-manifold 
    #Mesh has 5 non two manifold edges and 20 faces are incident on these edges
    # Filters | Cleaning & Repairing | Remove Faces from Non Manifold Edges
    # number or "two-manifold"
    if [ "$manifold" = "two-manifold" ]; then
        manifold="2-manifold"
        non_manifold_E="0"
        non_manifold_V="0"
    else
        isnumber "$manifold"
        if [ $? -eq 0 ] ; then
            non_manifold_E=$(grep -m1 "non two manifold edges" "$1" | cut -d" " -f3)
            non_manifold_V=$(grep -m1 "non two manifold vertexes" "$1" | cut -d" " -f3)
        else
            echo "What's going on here?"
        fi
        manifold="non-manifold"
    fi
    
    # Piping through tail -1 finds the LAST occurrence
    if [ "$manifold" = "2-manifold" ]; then
        num_holes=$(grep " holes" "$1" | tail -1 | cut -d" " -f3) # number of holes
        #Mesh has a undefined number of holes (non 2-manifold mesh)
        # number or "a"
        genus=$(grep -m1 "Genus is " "$1" | tail -1 | cut -d" " -f3) # mesh genus, i.e. how many "handles"
        #Genus is undefined (non 2-manifold mesh)
    else
        num_holes="undefined (non-manifold)"
        genus="undefined (non-manifold)"
    fi
  
    if [ "$verbosity" -ge 5 ]; then
        echo ; echo "***MeshLab Compute Topological Measures Results***"
        line_no=$(grep -n -m1 "V: " "$1" | cut -d":" -f1)
        tail -n +$line_no "$1"
        echo "***MeshLab Compute Topological Measures Results***"
    fi
    if [ "$verbosity" -ge 2 ]; then
        echo ; echo "***Parsed Topology Values***"
        echo "  Vertices: $num_V"
        echo "  Edges: $num_E"
        echo "  Faces: $num_F"
        echo
        echo "  Parts (Components): $num_parts"
        echo "  $manifold"
        echo "    Non 2-manifold Edges: $non_manifold_E"
        echo "    Non 2-manifold Vertices: $non_manifold_V"
        echo "    Holes: $num_holes"
        echo "    Boundary (Hole) Edges: $num_boundry_E"
        echo "    Genus: $genus"
        echo "  Unreferenced Vertices: ""$num_unref_V"
        echo "***Parsed Topology Values***"
    fi
    return 0
}

# Usage: mlx_section X=|Y=|(Z=0)|custom= surface=(false)
# TIP: surfaces can also be simplified after geneation
# Recommended extensions:
# surface: stl, obj
# line: dxf, obj (need to process obj)
# points: xyz (for measuring size)
mlx_section() {
    local i
    local axis # The slicing plane is perpendicular to this axis (default Z)
    local offset # cross-plane offset (default 0)
    local surface # true (default) will create a 2D surface, otherwise will create a 1D outline composed of line segments
    
    # Defaults
    axis=2 # Z axis
    offset="0"
    surface="false"
    
    if [ -z "$mlx_section_customAxis" ]; then mlx_section_customAxis=( 0 0 1 ); fi
    if [ -z "$mlx_section_planeref" ]; then mlx_section_planeref="2"; fi #0=BB Center, 1=BB Min, 2=Origin
    
    for i in "$@"
    do
    case $i in
        [xX]=*)
            axis=0 # X axis
            offset="${i#*=}"
            shift # past argument=value
            ;;
        [yY]=*)
            axis=1 # Y axis
            offset="${i#*=}"
            shift # past argument=value
            ;;
        [zZ]=*)
            axis=2 # Z axis
            offset="${i#*=}"
            shift # past argument=value
            ;;
        custom=*)
            axis=3 # Custom axis
            if [[ " ${mlx_section_customAxis[@]} " = " 0 0 1 " ]]; then
                echo ; echo "WARNING: mlx_section_customAxis is not set! Default value will be used."
            fi
            offset="${i#*=}"
            shift # past argument=value
            ;;
        surface=*)
            surface="${i#*=}"
            shift # past argument=value
            ;;
        *)
            # unknown option
            ;;
    esac
    done
    
    echo "\
    <filter name=\"Compute Planar Section\">
        <Param name=\"planeAxis\" description=\"Plane perpendicular to\" value=\"$axis\" enum_val0=\"X Axis\" enum_val1=\"Y Axis\" enum_val2=\"Z Axis\" enum_val3=\"Custom Axis\" enum_cardinality=\"4\" type=\"RichEnum\" tooltip=\"The Slicing plane will be done perpendicular to the axis\"/>
        <Param name=\"customAxis\" description=\"Custom axis\" x=\"${mlx_section_customAxis[0]}\" y=\"${mlx_section_customAxis[1]}\" z=\"${mlx_section_customAxis[2]}\" type=\"RichPoint3f\" tooltip=\"Specify a custom axis, this is only valid if the above parameter is set to Custom\"/>
        <Param name=\"planeOffset\" description=\"Cross plane offset\" value=\"$offset\" type=\"RichFloat\" tooltip=\"Specify an offset of the cross-plane. The offset corresponds to the distance from the point specified in the plane reference parameter. By default (Cross plane offset == 0)\"/>
        <Param name=\"relativeTo\" description=\"plane reference\" value=\"$mlx_section_planeref\" enum_val0=\"Bounding box center\" enum_val1=\"Bounding box min\" enum_val2=\"Origin\" enum_cardinality=\"3\" type=\"RichEnum\" tooltip=\"Specify the reference from which the planes are shifted\"/>
        <Param name=\"createSectionSurface\" description=\"Create also section surface\" value=\"$surface\" type=\"RichBool\" tooltip=\"If selected, in addition to a layer with the section polyline, it will be created also a layer with a triangulated version of the section polyline. This only works if the section polyline is closed\"/>
    </filter>" >> "$ml_SF"
}

### End Measure ###


### Begin Cleaning & Repair ###
# (Also see Selection & Deletion section for lots of cleaning functions)

# Usage: mlx_merge_V threshold=(0)
mlx_merge_V () {
    local i
    local threshold
    
    # Defaults
    threshold="0"
    
    for i in "$@"
    do
    case $i in
        t=*|threshold=*)
            threshold="${i#*=}"
            shift # past argument=value
            ;;
        *)
            # unknown option
            ;;
    esac
    done

    echo "\
    <filter name=\"Merge Close Vertices\">
        <Param name=\"Threshold\" description=\"Merging distance\" value=\"$threshold\"  min=\"0\" max=\"1\" type=\"RichAbsPerc\" tooltip=\"All the vertices that closer than this threshold are merged together. Use very small values, default values is 1/10000 of bounding box diagonal.\"/>
    </filter>" >> "$ml_SF"
}

# Usage: mlx_close_holes MaxHoleSize=(30)
# TIP: run subdivide on the slected faces next if the hole is large
# TODO: automatically subdivide based on how many edges are in hole. 
# Need to experiment to find good numbers.
# Run filter with progressivley larger hole sizes, subdiving by increasing amounts as hole gets bigger
mlx_close_holes() {
    local i
    local MaxHoleSize # Max hole size to be closed, as expressed as number of edges composing the hole boundary (default 30)
    
    # Defaults
    MaxHoleSize=30
    
    if [ -z "$mlx_close_holes_Selected" ]; then mlx_close_holes_Selected="false"; fi
    if [ -z "$mlx_close_holes_NewFaceSelected" ]; then mlx_close_holes_NewFaceSelected="true"; fi
    if [ -z "$mlx_close_holes_SelfIntersection" ]; then mlx_close_holes_SelfIntersection="true"; fi
    
    for i in "$@"
    do
    case $i in
        max=*|MaxHoleSize=*)
            MaxHoleSize="${i#*=}"
            shift # past argument=value
            ;;
        *)
            # unknown option
            ;;
    esac
    done
    
    echo "\
    <filter name=\"Close Holes\">
        <Param name=\"MaxHoleSize\" description=\"Max size to be closed \" value=\"$MaxHoleSize\" type=\"RichInt\" tooltip=\"The size is expressed as number of edges composing the hole boundary\"/>
        <Param name=\"Selected\" description=\"Close holes with selected faces\" value=\"$mlx_close_holes_Selected\" type=\"RichBool\" tooltip=\"Only the holes with at least one of the boundary faces selected are closed\"/>
        <Param name=\"NewFaceSelected\" description=\"Select the newly created faces\" value=\"$mlx_close_holes_NewFaceSelected\" type=\"RichBool\" tooltip=\"After closing a hole the faces that have been created are left selected. Any previous selection is lost. Useful for example for smoothing the newly created holes.\"/>
        <Param name=\"SelfIntersection\" description=\"Prevent creation of selfIntersecting faces\" value=\"$mlx_close_holes_SelfIntersection\" type=\"RichBool\" tooltip=\"When closing an holes it tries to prevent the creation of faces that intersect faces adjacent to the boundary of the hole. It is an heuristic, non intersetcting hole filling can be NP-complete.\"/>
    </filter>" >> "$ml_SF"
}

# Usage: mlx_grow_holes iterations=(3)
mlx_grow_holes() {
    local i
    local iterations
    
    # Defaults
    iterations="3"
    
    for i in "$@"
    do
    case $i in
        i=*|iterations=*)
            iterations="${i#*=}"
            shift # past argument=value
            ;;
        *)
            # unknown option
            ;;
    esac
    done
   
    mlx_sel_border
    mlx_grow_sel iterations="$iterations"
    mlx_del_sel_V_F
    mlx_del_unreferenced_V
}

mlx_reorient_normals() {
    echo "    <filter name=\"Re-Orient all faces coherentely\"/>" >> "$ml_SF"
}

mlx_flip_normals() {
    if [ -z "$mlx_flip_normals_forceFlip" ]; then mlx_flip_normals_forceFlip="true"; fi
    if [ -z "$mlx_flip_normals_Selected" ]; then mlx_flip_normals_Selected="false"; fi
    
    echo "\
    <filter name=\"Invert Faces Orientation\">
        <Param name=\"forceFlip\" description=\"Force Flip\" value=\"$mlx_flip_normals_forceFlip\" type=\"RichBool\" tooltip=\"If selected, the normals will always be flipped; otherwise, the filter tries to set them outside\"/>
        <Param name=\"onlySelected\" description=\"Flip only selected faces\" value=\"$mlx_flip_normals_Selected\" type=\"RichBool\" tooltip=\"If selected, only selected faces will be affected\"/>
    </filter>" >> "$ml_SF"
}

# TODO: what if you follow reorient normals with mlx_flip_normals with mlx_flip_normals_forceFlip=false; will this correct all normals?
mlx_fix_normals() {
    mlx_reorient_normals
    mlx_flip_normals_forceFlip="false"
    mlx_flip_normals
    mlx_flip_normals_forceFlip=""
}

mlx_split_V_on_nonmanifold_F() {
    if [ -z "$mlx_split_V_on_nonmanifold_F_VertDispRatio" ]; then mlx_split_V_on_nonmanifold_F_VertDispRatio="0"; fi
    
    echo "\
    <filter name=\"Split Vertexes Incident on Non Manifold Faces\">
        <Param name=\"VertDispRatio\" description=\"Vertex Displacement Ratio\" value=\"$mlx_split_V_on_nonmanifold_F_VertDispRatio\" type=\"RichFloat\" tooltip=\"When a vertex is split it is moved along the average vector going from its position to the baricyenter of the FF connected faces sharing it\"/>
    </filter>" >> "$ml_SF"
}

### End Cleaning & Repair ###


### Begin Selection & Deletion ###

mlx_sel_none() {
    if [ -z "$mlx_select_none_allFaces" ]; then mlx_select_none_allFaces="true"; fi
    if [ -z "$mlx_select_none_allVerts" ]; then mlx_select_none_allVerts="true"; fi

    echo "\
    <filter name=\"Select None\">
        <Param name=\"allFaces\" description=\"De-select all Faces\" value=\"$mlx_select_none_allFaces\" type=\"RichBool\" tooltip=\"If true the filter will de-select all the faces.\"/>
        <Param name=\"allVerts\" description=\"De-select all Vertices\" value=\"$mlx_select_none_allVerts\" type=\"RichBool\" tooltip=\"If true the filter will de-select all the vertices.\"/>
    </filter>" >> "$ml_SF"
}

mlx_invert_sel() {
    if [ -z "$mlx_invert_sel_InvFaces" ]; then mlx_invert_sel_InvFaces="true"; fi
    if [ -z "$mlx_invert_sel_InvVerts" ]; then mlx_invert_sel_InvVerts="true"; fi

    echo "\
    <filter name=\"Invert Selection\">
        <Param name=\"InvFaces\" description=\"Invert Faces\" value=\"$mlx_invert_sel_InvFaces\" type=\"RichBool\" tooltip=\"If true  the filter will invert the selected faces.\"/>
        <Param name=\"InvVerts\" description=\"Invert Vertices\" value=\"$mlx_invert_sel_InvVerts\" type=\"RichBool\" tooltip=\"If true the filter will invert the selected vertices.\"/>
    </filter>" >> "$ml_SF"
}

mlx_sel_border() {
    # Selects mesh boundary edges, e.g. holes in solid models or the edges of surfaces
    echo "    <filter name=\"Select Border\"/>" >> "$ml_SF"
}

# Usage: iterations=(1)
mlx_grow_sel() {
    local i
    local j
    local iterations
    
    # Defaults
    iterations="1"
    
    for i in "$@"
    do
    case $i in
        i=*|iterations=*)
            iterations="${i#*=}"
            shift # past argument=value
            ;;
        *)
            # unknown option
            ;;
    esac
    done
    
    j=0
    while [ $j -lt $iterations ]; do 
        echo "    <filter name=\"Dilate Selection\"/>" >> "$ml_SF"
        j=$(($j+1))
    done
}

# Usage: iterations=(1)
mlx_shrink_sel() {
    local i
    local j
    local iterations
    
    # Defaults
    iterations="1"
    
    for i in "$@"
    do
    case $i in
        i=*|iterations=*)
            iterations="${i#*=}"
            shift # past argument=value
            ;;
        *)
            # unknown option
            ;;
    esac
    done
    
    j=0
    while [ $j -lt $iterations ]; do 
        echo "    <filter name=\"Erode Selection\"/>" >> "$ml_SF"
        j=$(($j+1))
    done
}

mlx_sel_self_intersecting_F() {
    echo "    <filter name=\"Select Self Intersecting Faces\"/>" >> "$ml_SF"
}

mlx_sel_nonmanifold_V() {
    echo "    <filter name=\"Select non Manifold Vertices\"/>" >> "$ml_SF"
}

mlx_del_nonmanifold_V() {
    mlx_sel_nonmanifold_V
    mlx_del_sel_V
    #mlx_del_unreferenced_V
}

mlx_sel_nonmanifold_E() {
    echo "    <filter name=\"Select non Manifold Edges \"/>" >> "$ml_SF"
}

mlx_del_nonmanifold_E() {
    mlx_sel_nonmanifold_E
    mlx_del_sel_V
    #mlx_del_unreferenced_V
}

# Usage: ratio=(0.2)
mlx_sel_small_components() {
    local i
    local ratio # Small component ratio, this ratio (between 0 and 1) defines the meaning of "small" as the threshold ratio between the number of faces of the largest component and the other ones. A larger value will select more components. (default 0.2)
    
    # Defaults
    ratio="0.2"
    
    if [ -z "$mlx_sel_small_components_NonClosedOnly" ]; then mlx_sel_small_components_NonClosedOnly="false"; fi
    
    for i in "$@"
    do
    case $i in
        ratio=*)
            ratio="${i#*=}"
            shift # past argument=value
            ;;
        *)
            # unknown option
            ;;
    esac
    done
    
    echo "\
    <filter name=\"Small component selection\">
        <Param name=\"NbFaceRatio\" description=\"Small component ratio\"value=\"$ratio\" type=\"RichFloat\" tooltip=\"This ratio (between 0 and 1) defines the meaning of &lt;i>small&lt;/i> as the threshold ratio between the number of faces of the largest component and the other ones. A larger value will select more components.\"/>
        <Param name=\"NonClosedOnly\" description=\"Select only non closed components\" value=\"$mlx_sel_small_components_NonClosedOnly\" type=\"RichBool\" tooltip=\"\"/>
    </filter>" >> "$ml_SF"
}

# Usage: ratio=(0.2)
mlx_del_small_components() {
    mlx_sel_small_components "$@"
    mlx_del_sel_V_F
}

mlx_del_sel_V() {
    echo "    <filter name=\"Delete Selected Vertices\"/>" >> "$ml_SF"
}

mlx_del_sel_F() {
    echo "    <filter name=\"Delete Selected Faces\"/>" >> "$ml_SF"
}

mlx_del_sel_V_F() {
    echo "    <filter name=\"Delete Selected Faces and Vertices\"/>" >> "$ml_SF"
}

mlx_del_unreferenced_V() {
    echo "    <filter name=\"Remove Unreferenced Vertex\"/>" >> "$ml_SF"
}

# TIP: follow with measure_topology to check mesh
mlx_del_F_from_nonmanifold_E () {
    echo "    <filter name=\"Remove Faces from Non Manifold Edges\"/>" >> "$ml_SF"
    mlx_del_unreferenced_V
}

### End Selection & Deletion ###


### Begin Transformations ###

# Usage: X=(0) Y=(0) Z=(0)
# Usage: transX(mm) transY(mm) transZ(mm)
mlx_translate() {
    local i
    local transX
    local transY
    local transZ
    
    # Defaults
    transX=0
    transY=0
    transZ=0
    
    if [ -z "$mlx_translate_center" ]; then mlx_translate_center="false"; fi
    if [ -z "$mlx_translate_Freeze" ]; then mlx_translate_Freeze="true"; fi
    if [ -z "$mlx_translate_ToAll" ]; then mlx_translate_ToAll="false"; fi
    
    for i in "$@"
    do
    case $i in
        [xX]=*)
            transX="${i#*=}"
            shift # past argument=value
            ;;
        [yY]=*)
            transY="${i#*=}"
            shift # past argument=value
            ;;
        [zZ]=*)
            transZ="${i#*=}"
            shift # past argument=value
            ;;
        *)
            # unknown option
            ;;
    esac
    done
    
    echo "\
    <filter name=\"Transform: Move, Translate, Center\">
        <Param name=\"axisX\" description=\"X Axis\" value=\"$transX\" min=\"-500\" max=\"500\" type=\"RichDynamicFloat\" tooltip=\"Absolute translation amount along the X axis\"/>
        <Param name=\"axisY\" description=\"Y Axis\" value=\"$transY\" min=\"-500\" max=\"500\" type=\"RichDynamicFloat\" tooltip=\"Absolute translation amount along the Y axis\"/>
        <Param name=\"axisZ\" description=\"Z Axis\" value=\"$transZ\" min=\"-500\" max=\"500\" type=\"RichDynamicFloat\" tooltip=\"Absolute translation amount along the Z axis\"/>
        <Param name=\"centerFlag\" description=\"translate center of bbox to the origin\" value=\"$mlx_translate_center\"type=\"RichBool\" tooltip=\"If selected, the object is scaled to a box whose sides are at most 1 unit length\"/>
        <Param name=\"Freeze\" description=\"Freeze Matrix\" value=\"$mlx_translate_Freeze\" type=\"RichBool\" tooltip=\"The transformation is explicitly applied and the vertex coords are actually changed\"/>
        <Param name=\"ToAll\" description=\"Apply to all layers\" value=\"$mlx_translate_ToAll\" type=\"RichBool\" tooltip=\"The transformation is explicitly applied to all the mesh and raster layers in the project\"/>
    </filter>" >> "$ml_SF"
}

# Usage: axis=angle axis=angle ...
# NOTE: additional axis=angle pairs will stack and will be applied in the order listed
# Usage: rotAxis(x|y|z) angle(deg)
mlx_rotate() {
    local i
    local axis
    local angle
    
    # Defaults
    axis=2 # Z axis
    angle="0"
    
    if [ -z "$mlx_rotate_rotCenter" ]; then mlx_rotate_rotCenter="0"; fi #0=origin, 1=barycenter, 2=custom
    if [ -z "$mlx_rotate_snapFlag" ]; then mlx_rotate_snapFlag="false"; fi
    if [ -z "$mlx_rotate_customAxis" ]; then mlx_rotate_customAxis=( 0 0 0 ); fi
    if [ -z "$mlx_rotate_customCenter" ]; then mlx_rotate_customCenter=( 0 0 0 ); fi
    if [ -z "$mlx_rotate_snapAngle" ]; then mlx_rotate_snapAngle="30"; fi
    if [ -z "$mlx_rotate_Freeze" ]; then mlx_rotate_Freeze="true"; fi
    if [ -z "$mlx_rotate_ToAll" ]; then mlx_rotate_ToAll="false"; fi
    
    for i in "$@"
    do
    case $i in
        [xX]=*)
            axis=0 # X axis
            angle="${i#*=}"
            echo "\
    <filter name=\"Transform: Rotate\">
        <Param name=\"rotAxis\" description=\"Rotation on:\" value=\"$axis\" enum_val0=\"X axis\" enum_val1=\"Y axis\" enum_val2=\"Z axis\" enum_val3=\"custom axis\"  enum_cardinality=\"4\" type=\"RichEnum\" tooltip=\"Choose a method\"/>
        <Param name=\"rotCenter\" description=\"Center of rotation:\" value=\"$mlx_rotate_rotCenter\" enum_val0=\"origin\" enum_val1=\"barycenter\" enum_val2=\"custom point\" enum_cardinality=\"3\" type=\"RichEnum\" tooltip=\"Choose a method\"/>
        <Param name=\"angle\" description=\"Rotation Angle\" value=\"$angle\" min=\"-360\" max=\"360\" type=\"RichDynamicFloat\" tooltip=\"Angle of rotation (in &lt;b>degree&lt;/b>). If snapping is enabled this value is rounded according to the snap value\"/>
        <Param name=\"snapFlag\" description=\"Snap angle\" value=\"$mlx_rotate_snapFlag\" type=\"RichBool\" tooltip=\"If selected, before starting the filter will remove any unreferenced vertex (for which curvature values are not defined)\"/>
        <Param name=\"customAxis\" description=\"Custom axis\" x=\"${mlx_rotate_customAxis[0]}\" y=\"${mlx_rotate_customAxis[1]}\" z=\"${mlx_rotate_customAxis[2]}\" type=\"RichPoint3f\" tooltip=\"This rotation axis is used only if the 'custom axis' option is chosen.\"/>
        <Param name=\"customCenter\" description=\"Custom center\" x=\"${mlx_rotate_customCenter[0]}\" y=\"${mlx_rotate_customCenter[1]}\" z=\"${mlx_rotate_customCenter[2]}\" type=\"RichPoint3f\" tooltip=\"This rotation center is used only if the 'custom point' option is chosen.\"/>
        <Param name=\"snapAngle\" description=\"Snapping Value\" value=\"$mlx_rotate_snapAngle\" type=\"RichFloat\" tooltip=\"This value is used to snap the rotation angle.\"/>
        <Param name=\"Freeze\" description=\"Freeze Matrix\" value=\"$mlx_rotate_Freeze\" type=\"RichBool\" tooltip=\"The transformation is explicitly applied and the vertex coords are actually changed\"/>
        <Param name=\"ToAll\" description=\"Apply to all layers\" value=\"$mlx_rotate_ToAll\" type=\"RichBool\" tooltip=\"The transformation is explicitly applied to all the mesh and raster layers in the project\"/>
    </filter>" >> "$ml_SF"
            shift # past argument=value
            ;;
        [yY]=*)
            axis=1 # Y axis
            angle="${i#*=}"
            echo "\
    <filter name=\"Transform: Rotate\">
        <Param name=\"rotAxis\" description=\"Rotation on:\" value=\"$axis\" enum_val0=\"X axis\" enum_val1=\"Y axis\" enum_val2=\"Z axis\" enum_val3=\"custom axis\"  enum_cardinality=\"4\" type=\"RichEnum\" tooltip=\"Choose a method\"/>
        <Param name=\"rotCenter\" description=\"Center of rotation:\" value=\"$mlx_rotate_rotCenter\" enum_val0=\"origin\" enum_val1=\"barycenter\" enum_val2=\"custom point\" enum_cardinality=\"3\" type=\"RichEnum\" tooltip=\"Choose a method\"/>
        <Param name=\"angle\" description=\"Rotation Angle\" value=\"$angle\" min=\"-360\" max=\"360\" type=\"RichDynamicFloat\" tooltip=\"Angle of rotation (in &lt;b>degree&lt;/b>). If snapping is enabled this value is rounded according to the snap value\"/>
        <Param name=\"snapFlag\" description=\"Snap angle\" value=\"$mlx_rotate_snapFlag\" type=\"RichBool\" tooltip=\"If selected, before starting the filter will remove any unreferenced vertex (for which curvature values are not defined)\"/>
        <Param name=\"customAxis\" description=\"Custom axis\" x=\"${mlx_rotate_customAxis[0]}\" y=\"${mlx_rotate_customAxis[1]}\" z=\"${mlx_rotate_customAxis[2]}\" type=\"RichPoint3f\" tooltip=\"This rotation axis is used only if the 'custom axis' option is chosen.\"/>
        <Param name=\"customCenter\" description=\"Custom center\" x=\"${mlx_rotate_customCenter[0]}\" y=\"${mlx_rotate_customCenter[1]}\" z=\"${mlx_rotate_customCenter[2]}\" type=\"RichPoint3f\" tooltip=\"This rotation center is used only if the 'custom point' option is chosen.\"/>
        <Param name=\"snapAngle\" description=\"Snapping Value\" value=\"$mlx_rotate_snapAngle\" type=\"RichFloat\" tooltip=\"This value is used to snap the rotation angle.\"/>
        <Param name=\"Freeze\" description=\"Freeze Matrix\" value=\"$mlx_rotate_Freeze\" type=\"RichBool\" tooltip=\"The transformation is explicitly applied and the vertex coords are actually changed\"/>
        <Param name=\"ToAll\" description=\"Apply to all layers\" value=\"$mlx_rotate_ToAll\" type=\"RichBool\" tooltip=\"The transformation is explicitly applied to all the mesh and raster layers in the project\"/>
    </filter>" >> "$ml_SF"
            shift # past argument=value
            ;;
        [zZ]=*)
            axis=2 # Z axis
            angle="${i#*=}"
            echo "\
    <filter name=\"Transform: Rotate\">
        <Param name=\"rotAxis\" description=\"Rotation on:\" value=\"$axis\" enum_val0=\"X axis\" enum_val1=\"Y axis\" enum_val2=\"Z axis\" enum_val3=\"custom axis\"  enum_cardinality=\"4\" type=\"RichEnum\" tooltip=\"Choose a method\"/>
        <Param name=\"rotCenter\" description=\"Center of rotation:\" value=\"$mlx_rotate_rotCenter\" enum_val0=\"origin\" enum_val1=\"barycenter\" enum_val2=\"custom point\" enum_cardinality=\"3\" type=\"RichEnum\" tooltip=\"Choose a method\"/>
        <Param name=\"angle\" description=\"Rotation Angle\" value=\"$angle\" min=\"-360\" max=\"360\" type=\"RichDynamicFloat\" tooltip=\"Angle of rotation (in &lt;b>degree&lt;/b>). If snapping is enabled this value is rounded according to the snap value\"/>
        <Param name=\"snapFlag\" description=\"Snap angle\" value=\"$mlx_rotate_snapFlag\" type=\"RichBool\" tooltip=\"If selected, before starting the filter will remove any unreferenced vertex (for which curvature values are not defined)\"/>
        <Param name=\"customAxis\" description=\"Custom axis\" x=\"${mlx_rotate_customAxis[0]}\" y=\"${mlx_rotate_customAxis[1]}\" z=\"${mlx_rotate_customAxis[2]}\" type=\"RichPoint3f\" tooltip=\"This rotation axis is used only if the 'custom axis' option is chosen.\"/>
        <Param name=\"customCenter\" description=\"Custom center\" x=\"${mlx_rotate_customCenter[0]}\" y=\"${mlx_rotate_customCenter[1]}\" z=\"${mlx_rotate_customCenter[2]}\" type=\"RichPoint3f\" tooltip=\"This rotation center is used only if the 'custom point' option is chosen.\"/>
        <Param name=\"snapAngle\" description=\"Snapping Value\" value=\"$mlx_rotate_snapAngle\" type=\"RichFloat\" tooltip=\"This value is used to snap the rotation angle.\"/>
        <Param name=\"Freeze\" description=\"Freeze Matrix\" value=\"$mlx_rotate_Freeze\" type=\"RichBool\" tooltip=\"The transformation is explicitly applied and the vertex coords are actually changed\"/>
        <Param name=\"ToAll\" description=\"Apply to all layers\" value=\"$mlx_rotate_ToAll\" type=\"RichBool\" tooltip=\"The transformation is explicitly applied to all the mesh and raster layers in the project\"/>
    </filter>" >> "$ml_SF"
            shift # past argument=value
            ;;
        custom=*)
            axis=3 # Custom axis
            if [[ " ${mlx_rotate_customAxis[@]} " = " 0 0 0 " ]]; then
                echo ; echo "WARNING: mlx_rotate_customAxis is not set! Default value will be used."
            fi
            angle="${i#*=}"
            echo "\
    <filter name=\"Transform: Rotate\">
        <Param name=\"rotAxis\" description=\"Rotation on:\" value=\"$axis\" enum_val0=\"X axis\" enum_val1=\"Y axis\" enum_val2=\"Z axis\" enum_val3=\"custom axis\"  enum_cardinality=\"4\" type=\"RichEnum\" tooltip=\"Choose a method\"/>
        <Param name=\"rotCenter\" description=\"Center of rotation:\" value=\"$mlx_rotate_rotCenter\" enum_val0=\"origin\" enum_val1=\"barycenter\" enum_val2=\"custom point\" enum_cardinality=\"3\" type=\"RichEnum\" tooltip=\"Choose a method\"/>
        <Param name=\"angle\" description=\"Rotation Angle\" value=\"$angle\" min=\"-360\" max=\"360\" type=\"RichDynamicFloat\" tooltip=\"Angle of rotation (in &lt;b>degree&lt;/b>). If snapping is enabled this value is rounded according to the snap value\"/>
        <Param name=\"snapFlag\" description=\"Snap angle\" value=\"$mlx_rotate_snapFlag\" type=\"RichBool\" tooltip=\"If selected, before starting the filter will remove any unreferenced vertex (for which curvature values are not defined)\"/>
        <Param name=\"customAxis\" description=\"Custom axis\" x=\"${mlx_rotate_customAxis[0]}\" y=\"${mlx_rotate_customAxis[1]}\" z=\"${mlx_rotate_customAxis[2]}\" type=\"RichPoint3f\" tooltip=\"This rotation axis is used only if the 'custom axis' option is chosen.\"/>
        <Param name=\"customCenter\" description=\"Custom center\" x=\"${mlx_rotate_customCenter[0]}\" y=\"${mlx_rotate_customCenter[1]}\" z=\"${mlx_rotate_customCenter[2]}\" type=\"RichPoint3f\" tooltip=\"This rotation center is used only if the 'custom point' option is chosen.\"/>
        <Param name=\"snapAngle\" description=\"Snapping Value\" value=\"$mlx_rotate_snapAngle\" type=\"RichFloat\" tooltip=\"This value is used to snap the rotation angle.\"/>
        <Param name=\"Freeze\" description=\"Freeze Matrix\" value=\"$mlx_rotate_Freeze\" type=\"RichBool\" tooltip=\"The transformation is explicitly applied and the vertex coords are actually changed\"/>
        <Param name=\"ToAll\" description=\"Apply to all layers\" value=\"$mlx_rotate_ToAll\" type=\"RichBool\" tooltip=\"The transformation is explicitly applied to all the mesh and raster layers in the project\"/>
    </filter>" >> "$ml_SF"
            shift # past argument=value
            ;;
        *)
            # unknown option
            ;;
    esac
    done
}

# Usage: scale=(1)|(X=(1) Y=(1) Z=(1))
mlx_scale() {
    local i
    local scaleX
    local scaleY
    local scaleZ
    local uniform
    
    # Defaults
    scaleX=1
    scaleY=1
    scaleZ=1
    uniform="true"
    
    if [ -z "$mlx_scale_center" ]; then mlx_scale_center="0"; fi #0=origin, 1=barycenter, 2=custom
    if [ -z "$mlx_scale_customCenter" ]; then mlx_scale_customCenter=( 0 0 0 ); fi
    if [ -z "$mlx_scale_unit" ]; then mlx_scale_unit="false"; fi
    if [ -z "$mlx_scale_Freeze" ]; then mlx_scale_Freeze="true"; fi
    if [ -z "$mlx_scale_ToAll" ]; then mlx_scale_ToAll="false"; fi
    
    for i in "$@"
    do
    case $i in
        s=*|scale=*)
            scaleX="${i#*=}"
            scaleY="${i#*=}"
            scaleZ="${i#*=}"
            shift # past argument=value
            ;;
        [xX]=*)
            scaleX="${i#*=}"
            uniform="false"
            shift # past argument=value
            ;;
        [yY]=*)
            scaleY="${i#*=}"
            uniform="false"
            shift # past argument=value
            ;;
        [zZ]=*)
            scaleZ="${i#*=}"
            uniform="false"
            shift # past argument=value
            ;;
        *)
            # unknown option
            ;;
    esac
    done
    
    echo "\
    <filter name=\"Transform: Scale\">
        <Param name=\"axisX\" description=\"X Axis\" value=\"$scaleX\" type=\"RichFloat\" tooltip=\"Scaling\"/>
        <Param name=\"axisY\" description=\"Y Axis\" value=\"$scaleY\" type=\"RichFloat\" tooltip=\"Scaling\"/>
        <Param name=\"axisZ\" description=\"Z Axis\" value=\"$scaleZ\" type=\"RichFloat\" tooltip=\"Scaling\"/>
        <Param name=\"uniformFlag\" description=\"Uniform Scaling\" value=\"$uniform\" type=\"RichBool\" tooltip=\"If selected an uniform scaling (the same for all the three axis) is applied (the X axis value is used)\"/>
        <Param name=\"scaleCenter\" description=\"Center of scaling:\" value=\"$mlx_scale_center\" enum_val0=\"origin\" enum_val1=\"barycenter\" enum_val2=\"custom point\" enum_cardinality=\"3\" type=\"RichEnum\" tooltip=\"Choose a method\"/>
        <Param name=\"customCenter\" description=\"Custom center\" x=\"${mlx_scale_customCenter[0]}\" y=\"${mlx_scale_customCenter[1]}\" z=\"${mlx_scale_customCenter[2]}\" type=\"RichPoint3f\" tooltip=\"This scaling center is used only if the 'custom point' option is chosen.\"/>
        <Param name=\"unitFlag\" description=\"Scale to Unit bbox\" value=\"$mlx_scale_unit\" type=\"RichBool\" tooltip=\"If selected, the object is scaled to a box whose sides are at most 1 unit length\"/>
        <Param name=\"Freeze\" description=\"Freeze Matrix\" value=\"$mlx_scale_Freeze\" type=\"RichBool\" tooltip=\"The transformation is explicitly applied and the vertex coords are actually changed\"/>
        <Param name=\"ToAll\" description=\"Apply to all layers\" value=\"$mlx_scale_ToAll\" type=\"RichBool\" tooltip=\"The transformation is explicitly applied to all the mesh and raster layers in the project\"/>
    </filter>" >> "$ml_SF"
}

mlx_freeze_matrix() {
    if [ -z "$mlx_freeze_matrix_allLayers" ]; then mlx_freeze_matrix_allLayers="false"; fi

    echo "\
    <filter name=\"Freeze Current Matrix\">
        <Param name=\"allLayers\" description=\"Apply to all visible Layers\" value=\"$mlx_freeze_matrix_allLayers\" type=\"RichBool\" tooltip=\"If selected the filter will be applied to all visible layers\"/>
    </filter>" >> "$ml_SF"
}

### End Transformations ###


### Begin Remeshing ###

# Usage: faces=(25000)
# TIP: measure topology fist to find number of faces and area
mlx_simplify() {
    local i
    local faces
    
    # Defaults
    faces=25000
    
    if [ -z "$mlx_simplify_TargetPerc" ]; then mlx_simplify_TargetPerc="0"; fi
    if [ -z "$mlx_simplify_QualityThr" ]; then mlx_simplify_QualityThr="0.3"; fi
    if [ -z "$mlx_simplify_PreserveBoundary" ]; then mlx_simplify_PreserveBoundary="false"; fi
    if [ -z "$mlx_simplify_BoundaryWeight" ]; then mlx_simplify_BoundaryWeight="1"; fi
    if [ -z "$mlx_simplify_PreserveNormal" ]; then mlx_simplify_PreserveNormal="false"; fi
    if [ -z "$mlx_simplify_OptimalPlacement" ]; then mlx_simplify_OptimalPlacement="true"; fi
    if [ -z "$mlx_simplify_PlanarQuadric" ]; then mlx_simplify_PlanarQuadric="false"; fi
    if [ -z "$mlx_simplify_Selected" ]; then mlx_simplify_Selected="false"; fi
    
    for i in "$@"
    do
    case $i in
        [fF]=*|faces=*)
            faces="${i#*=}"
            shift # past argument=value
            ;;
        *)
            # unknown option
            ;;
    esac
    done
    
    if [ -z "$m_color" ]; then set_m_color "$ml_IF"; fi # set m_color based on input file
    if [ "$m_color" = "UV" ]; then
        if [ -z "$mlx_simplify_Extratcoordw" ]; then mlx_simplify_Extratcoordw="1"; fi
        echo "\
    <filter name=\"Quadric Edge Collapse Decimation (with texture)\">
        <Param name=\"TargetFaceNum\" description=\"Target number of faces\" value=\"$faces\" type=\"RichInt\" tooltip=\"\"/>
        <Param name=\"TargetPerc\" description=\"Percentage reduction (0..1)\" value=\"$mlx_simplify_TargetPerc\" type=\"RichFloat\" tooltip=\"If non zero, this parameter specifies the desired final size of the mesh as a percentage of the initial mesh.\"/>
        <Param name=\"QualityThr\" description=\"Quality threshold\" value=\"$mlx_simplify_QualityThr\" type=\"RichFloat\" tooltip=\"Quality threshold for penalizing bad shaped faces.&lt;br>The value is in the range [0..1]&#xa; 0 accept any kind of face (no penalties),&#xa; 0.5  penalize faces with quality &lt; 0.5, proportionally to their shape&#xa;\"/>
        <Param name=\"Extratcoordw\" description=\"Texture Weight\" value=\"$mlx_simplify_Extratcoordw\" type=\"RichFloat\" tooltip=\"Additional weight for each extra Texture Coordinates for every (selected) vertex\"/>
        <Param name=\"PreserveBoundary\" description=\"Preserve Boundary of the mesh\" value=\"$mlx_simplify_PreserveBoundary\" type=\"RichBool\" tooltip=\"The simplification process tries not to destroy mesh boundaries\"/>
        <Param name=\"BoundaryWeight\" description=\"Boundary Preserving Weight\" value=\"$mlx_simplify_BoundaryWeight\" type=\"RichFloat\" tooltip=\"The importance of the boundary during simplification. Default (1.0) means that the boundary has the same importance of the rest. Values greater than 1.0 raise boundary importance and has the effect of removing less vertices on the border. Admitted range of values (0,+inf). \"/>
        <Param name=\"OptimalPlacement\" description=\"Optimal position of simplified vertices\" value=\"$mlx_simplify_OptimalPlacement\" type=\"RichBool\" tooltip=\"Each collapsed vertex is placed in the position minimizing the quadric error.&#xa; It can fail (creating bad spikes) in case of very flat areas. &#xa;If disabled edges are collapsed onto one of the two original vertices and the final mesh is composed by a subset of the original vertices.\"/>
        <Param name=\"PreserveNormal\" description=\"Preserve Normal\" value=\"$mlx_simplify_PreserveNormal\" type=\"RichBool\" tooltip=\"Try to avoid face flipping effects and try to preserve the original orientation of the surface\"/>
        <Param name=\"PlanarQuadric\" description=\"Planar Simplification\" value=\"$mlx_simplify_PlanarQuadric\" type=\"RichBool\" tooltip=\"Add additional simplification constraints that improves the quality of the simplification of the planar portion of the mesh.\"/>
        <Param name=\"Selected\" description=\"Simplify only selected faces\" value=\"$mlx_simplify_Selected\" type=\"RichBool\" tooltip=\"The simplification is applied only to the selected set of faces.&#xa; Take care of the target number of faces!\"/>
    </filter>" >> "$ml_SF"
    else
        if [ -z "$mlx_simplify_PreserveTopology" ]; then mlx_simplify_PreserveTopology="true"; fi
        if [ -z "$mlx_simplify_QualityWeight" ]; then mlx_simplify_QualityWeight="false"; fi
        if [ -z "$mlx_simplify_AutoClean" ]; then mlx_simplify_AutoClean="true"; fi
        echo "\
    <filter name=\"Quadric Edge Collapse Decimation\">
        <Param name=\"TargetFaceNum\" description=\"Target number of faces\" value=\"$faces\" type=\"RichInt\" tooltip=\"The desired final number of faces.\"/>
        <Param name=\"TargetPerc\" description=\"Percentage reduction (0..1)\" value=\"$mlx_simplify_TargetPerc\" type=\"RichFloat\" tooltip=\"If non zero, this parameter specifies the desired final size of the mesh as a percentage of the initial size.\"/>
        <Param name=\"QualityThr\" description=\"Quality threshold\" value=\"$mlx_simplify_QualityThr\" type=\"RichFloat\" tooltip=\"Quality threshold for penalizing bad shaped faces.&lt;br>The value is in the range [0..1]&#xa; 0 accept any kind of face (no penalties),&#xa; 0.5  penalize faces with quality &lt; 0.5, proportionally to their shape&#xa;\"/>
        <Param name=\"PreserveBoundary\" description=\"Preserve Boundary of the mesh\" value=\"$mlx_simplify_PreserveBoundary\" type=\"RichBool\" tooltip=\"The simplification process tries to do not affect mesh boundaries during simplification\"/>
        <Param name=\"BoundaryWeight\" description=\"Boundary Preserving Weight\" value=\"$mlx_simplify_BoundaryWeight\" type=\"RichFloat\" tooltip=\"The importance of the boundary during simplification. Default (1.0) means that the boundary has the same importance of the rest. Values greater than 1.0 raise boundary importance and has the effect of removing less vertices on the border. Admitted range of values (0,+inf).\"/>
        <Param name=\"PreserveNormal\" description=\"Preserve Normal\" value=\"$mlx_simplify_PreserveNormal\" type=\"RichBool\" tooltip=\"Try to avoid face flipping effects and try to preserve the original orientation of the surface\"/>
        <Param name=\"PreserveTopology\" description=\"Preserve Topology\" value=\"$mlx_simplify_PreserveTopology\" type=\"RichBool\" tooltip=\"Avoid all the collapses that should cause a topology change in the mesh (like closing holes, squeezing handles, etc). If checked the genus of the mesh should stay unchanged.\"/>
        <Param name=\"OptimalPlacement\" description=\"Optimal position of simplified vertices\" value=\"$mlx_simplify_OptimalPlacement\" type=\"RichBool\" tooltip=\"Each collapsed vertex is placed in the position minimizing the quadric error.&#xa; It can fail (creating bad spikes) in case of very flat areas. &#xa;If disabled edges are collapsed onto one of the two original vertices and the final mesh is composed by a subset of the original vertices.\"/>
        <Param name=\"PlanarQuadric\" description=\"Planar Simplification\" value=\"$mlx_simplify_PlanarQuadric\" type=\"RichBool\" tooltip=\"Add additional simplification constraints that improves the quality of the simplification of the planar portion of the mesh.\"/>
        <Param name=\"QualityWeight\" description=\"Weighted Simplification\" value=\"$mlx_simplify_QualityWeight\" type=\"RichBool\" tooltip=\"Use the Per-Vertex quality as a weighting factor for the simplification. The weight is used as a error amplification value, so a vertex with a high quality value will not be simplified and a portion of the mesh with low quality values will be aggressively simplified.\"/>
        <Param name=\"AutoClean\" description=\"Post-simplification cleaning\" value=\"$mlx_simplify_AutoClean\" type=\"RichBool\" tooltip=\"After the simplification an additional set of steps is performed to clean the mesh (unreferenced vertices, bad faces, etc)\"/>
        <Param name=\"Selected\" description=\"Simplify only selected faces\" value=\"$mlx_simplify_Selected\" type=\"RichBool\" tooltip=\"The simplification is applied only to the selected set of faces.&#xa; Take care of the target number of faces!\"/>
    </filter>" >> "$ml_SF"
    fi
}

# Usage: voxel=(1) delta=(0)
mlx_offset() {
    # BBdiag will be used to set maxes and mins if available
    # If you prefer to use a precision (as a percentage of the
    # BBdiag) instead of the voxel cell size include the following code
    # in the parent and pass offset_CellSize:
    #   offset_precision="1" # 1% of BBdiag
    #   offset_CellSize=$(bc <<< "($BBdiag * 0.01 * $offset_precision)")
    
    local i
    local voxel # voxel cell size for resampling
    local delta # offset amount; negative values offset inwards (inset)
    local voxelMax
    local deltaMin
    local deltaMax
    
    # Defaults
    voxel=1
    delta=0
    if [ -n "$BBdiag" ]; then
        voxelMax="$BBdiag"
        deltaMin=$(bc <<< "($BBdiag * 0.2 * -1)") #-20% of BBdiag
        deltaMax=$(bc <<< "($BBdiag * 0.2)") #+20% of BBdiag
    else
        voxelMax="100"
        deltaMin="100"
        deltaMax="100"
    fi

    if [ -z "$mlx_offset_merge_V" ]; then mlx_offset_merge_V="true"; fi
    if [ -z "$mlx_offset_discretize" ]; then mlx_offset_discretize="false"; fi
    if [ -z "$mlx_offset_multisample" ]; then mlx_offset_multisample="false"; fi
    if [ -z "$mlx_offset_absDist" ]; then mlx_offset_absDist="false"; fi
    
    for i in "$@"
    do
    case $i in
        voxel=*)
            voxel="${i#*=}"
            shift # past argument=value
            ;;
        d=*|delta=*)
            delta="${i#*=}"
            shift # past argument=value
            ;;
        *)
            # unknown option
            ;;
    esac
    done
    
    echo "\
    <filter name=\"Uniform Mesh Resampling\">
        <Param name=\"CellSize\" description=\"Precision\" value=\"$voxel\" min=\"0\" max=\"$voxelMax\" type=\"RichAbsPerc\" tooltip=\"Size of the cell, the default is 1/50 of the box diag. Smaller cells give better precision at a higher computational cost. Remember that halving the cell size means that you build a volume 8 times larger.\"/>
        <Param name=\"Offset\" description=\"Offset\" value=\"$delta\" min=\"$deltaMin\" max=\"$deltaMax\" type=\"RichAbsPerc\" tooltip=\"Offset of the created surface (i.e. distance of the created surface from the original one).&lt;br>If offset is zero, the created surface passes on the original mesh itself. Values greater than zero mean an external surface, and lower than zero mean an internal surface.&lt;br> In practice this value is the threshold passed to the Marching Cube algorithm to extract the isosurface from the distance field representation.\"/>
        <Param name=\"mergeCloseVert\" description=\"Clean Vertices\" value=\"$mlx_offset_merge_V\" type=\"RichBool\" tooltip=\"If true the mesh generated by MC will be cleaned by unifying vertices that are almost coincident\"/>
        <Param name=\"discretize\" description=\"Discretize\" value=\"$mlx_offset_discretize\" type=\"RichBool\" tooltip=\"If true the position of the intersected edge of the marching cube grid is not computed by linear interpolation, but it is placed in fixed middle position. As a consequence the resampled object will look severely aliased by a stairstep appearance.&lt;br>Useful only for simulating the output of 3D printing devices.\"/>
        <Param name=\"multisample\" description=\"Multisample\" value=\"$mlx_offset_multisample\" type=\"RichBool\" tooltip=\"If true the distance field is more accurately compute by multisampling the volume (7 sample for each voxel). Much slower but less artifacts.\"/>
        <Param name=\"absDist\" description=\"Absolute Distance\" value=\"$mlx_offset_absDist\" type=\"RichBool\" tooltip=\"If true a &lt;b> not&lt;/b> signed distance field is computed. In this case you have to choose a not zero Offset and a double surface is built around the original surface, inside and outside. Is useful to convert thin floating surfaces into &lt;i> solid, thick meshes.&lt;/i>.\"/>
    </filter>" >> "$ml_SF"
}

# Usage: iterations=(1)
mlx_subdivide() {
    local i
    local iterations
    
    # Defaults
    iterations="1"
    
    if [ -z "$mlx_subdivide_LoopWeight" ]; then mlx_subdivide_LoopWeight="0"; fi
    if [ -z "$mlx_subdivide_Threshold" ]; then mlx_subdivide_Threshold="0"; fi
    if [ -z "$mlx_subdivide_Selected" ]; then mlx_subdivide_Selected="false"; fi
    
    for i in "$@"
    do
    case $i in
        i=*|iterations=*)
            iterations="${i#*=}"
            shift # past argument=value
            ;;
        *)
            # unknown option
            ;;
    esac
    done
    
    echo "\
    <filter name=\"Subdivision Surfaces: Loop\">
        <Param name=\"LoopWeight\" description=\"Weighting scheme\" value=\"$mlx_subdivide_LoopWeight\" enum_val0=\"Loop\" enum_val1=\"Enhance regularity\" enum_val2=\"Enhance continuity\" enum_cardinality=\"3\" type=\"RichEnum\" tooltip=\"Change the weights used. Allow to optimize some behaviours in spite of others.\"/>
        <Param name=\"Iterations\" description=\"Iterations\" value=\"$iterations\" type=\"RichInt\" tooltip=\"Number of times the model is subdivided.\"/>
        <Param name=\"Threshold\" description=\"Edge Threshold\" value=\"$mlx_subdivide_Threshold\" min=\"0\" max=\"100\" type=\"RichAbsPerc\" tooltip=\"All the edges &lt;b>longer&lt;/b> than this threshold will be refined.&lt;br>Setting this value to zero will force an uniform refinement.\"/>
        <Param name=\"Selected\" description=\"Affect only selected faces\" value=\"$mlx_subdivide_Selected\" type=\"RichBool\" tooltip=\"If selected the filter affect only the selected faces\"/>
    </filter>" >> "$ml_SF"
}

# Usage: iterations=(1)
mlx_smooth() {
    local i
    local iterations
    
    # Defaults
    iterations="1"
    
    if [ -z "$mlx_smooth_Boundary" ]; then mlx_smooth_Boundary="true"; fi
    if [ -z "$mlx_smooth_cotangentWeight" ]; then mlx_smooth_cotangentWeight="true"; fi
    if [ -z "$mlx_smooth_Selected" ]; then mlx_smooth_Selected="false"; fi
    
    for i in "$@"
    do
    case $i in
        i=*|iterations=*)
            iterations="${i#*=}"
            shift # past argument=value
            ;;
        *)
            # unknown option
            ;;
    esac
    done
    
    echo "\
    <filter name=\"Laplacian Smooth\">
        <Param name=\"stepSmoothNum\" description=\"Smoothing steps\" value=\"$iterations\" type=\"RichInt\" tooltip=\"The number of times that the whole algorithm (normal smoothing + vertex fitting) is iterated.\"/>
        <Param name=\"Boundary\" description=\"1D Boundary Smoothing\" value=\"$mlx_smooth_Boundary\" type=\"RichBool\" tooltip=\"If true the boundary edges are smoothed only by themselves (e.g. the polyline forming the boundary of the mesh is independently smoothed). Can reduce the shrinking on the border but can have strange effects on very small boundaries.\"/>
        <Param name=\"cotangentWeight\" description=\"Cotangent weighting\" value=\"$mlx_smooth_cotangentWeight\" type=\"RichBool\" tooltip=\"If true the cotangent weighting scheme is computed for the averaging of the position. Otherwise (false) the simpler umbrella scheme (1 if the edge is present) is used.\"/>
        <Param name=\"Selected\" description=\"Affect only selected faces\" value=\"$mlx_smooth_Selected\" type=\"RichBool\" tooltip=\"If checked the filter is performed only on the selected faces\"/>
    </filter>" >> "$ml_SF"
}

mlx_hull() {
    if [ -z "$mlx_hull_reorient" ]; then mlx_hull_reorient="true"; fi

    echo "\
    <filter name=\"Convex Hull\">
        <Param name=\"reorient\" description=\"Re-orient all faces coherentely\" value=\"$mlx_hull_reorient\" type=\"RichBool\" tooltip=\"Re-orient all faces coherentely\"/>
    </filter>" >> "$ml_SF"
}

### End Remeshing ###


### Begin Mesh Layers ###

# Usage: merge_V=(false)
# NOTE: filter will discard textures, creates a new layer "Merged Mesh"
#mlx_flatten_layers_merge_V looks to be a key one; experiment with this
mlx_flatten_layers() {
    local i
    local merge_V
    
    # Defaults
    merge_V="false"

    if [ -z "$mlx_flatten_layers_MergeVisible" ]; then mlx_flatten_layers_MergeVisible="true"; fi
    if [ -z "$mlx_flatten_layers_del_Layer" ]; then mlx_flatten_layers_del_Layer="true"; fi
    if [ -z "$mlx_flatten_layers_Keep_Unreferenced_V" ]; then mlx_flatten_layers_Keep_Unreferenced_V="false"; fi
    
    for i in "$@"
    do
    case $i in
        merge_V=*)
            merge_V="${i#*=}"
            shift # past argument=value
            ;;
        *)
            # unknown option
            ;;
    esac
    done

    echo "\
    <filter name=\"Flatten Visible Layers\">
        <Param name=\"MergeVisible\" description=\"Merge Only Visible Layers\" value=\"$mlx_flatten_layers_MergeVisible\" type=\"RichBool\" tooltip=\"Merge the vertices that are duplicated among different layers. &lt;br>Very useful when the layers are spliced portions of a single big mesh.\"/>
        <Param name=\"DeleteLayer\" description=\"Delete Layers \" value=\"$mlx_flatten_layers_del_Layer\" type=\"RichBool\" tooltip=\"Delete all the merged layers. &lt;br>If all layers are visible only a single layer will remain after the invocation of this filter\"/>
        <Param name=\"MergeVertices\" description=\"Merge duplicate vertices\" value=\"$merge_V\" type=\"RichBool\" tooltip=\"Merge the vertices that are duplicated among different layers. &#xa;&#xa;Very useful when the layers are spliced portions of a single big mesh.\"/>
        <Param name=\"AlsoUnreferenced\" description=\"Keep unreferenced vertices\" value=\"$mlx_flatten_layers_Keep_Unreferenced_V\" type=\"RichBool\" tooltip=\"Do not discard unreferenced vertices from source layers&#xa;&#xa;Necessary for point-only layers\"/>
    </filter>" >> "$ml_SF"
}

# deletes current layer
mlx_del_layer() {
    echo "    <filter name=\"Delete Current Mesh\"/>" >> "$ml_SF"
}

# Usage: layer=name
# renames current layer
mlx_rename_layer() {
    local i
    local layer
    
    for i in "$@"
    do
    case $i in
        l=*|layer=*)
            layer="${i#*=}"
            shift # past argument=value
            ;;
        *)
            # unknown option
            ;;
    esac
    done
    
    echo "\
    <filter name=\"Rename Current Mesh\">
        <Param name=\"newName\" description=\"New Label\" value=\"$layer\" type=\"RichString\" tooltip=\"New Label for the mesh\"/>
    </filter>" >> "$ml_SF"
}

# Usage: layer=name
# NEED TO TEST
# Note" default value was "0"; does this need to be the name of the layer or its number in the stack?
mlx_change_layer() {
    local i
    local layer
    
    for i in "$@"
    do
    case $i in
        l=*|layer=*)
            layer="${i#*=}"
            shift # past argument=value
            ;;
        *)
            # unknown option
            ;;
    esac
    done
    
    echo "\
    <filter name=\"Change the current layer\">
        <Param name=\"mesh\" description=\"Mesh\" value=\"$layer\" type=\"RichMesh\" tooltip=\"The name of the current mesh\"/>
    </filter>" >> "$ml_SF"
}

mlx_copy_layer() {
# creates new layer named "*_copy"
    echo "    <filter name=\"Duplicate Current layer\"/>" >> "$ml_SF"
}

mlx_split_components() {
# Creates layers named "CC 0", "CC 1", etc.
# This doesn't preserve textures!
    echo "    <filter name=\"Split in Connected Components\"/>" >> "$ml_SF"
}

### End Mesh Layers ###


### Begin Create ###
# TODO: how to create new items without an input file? Import file then immediately delete layer as the first step is a valid workaround. Opening an empty mlp project didn't seem to work.

# Usage: size=(1)|(X=(1) Y=(1) Z=(1)) center=(false)
# Usage: (size(mm))|(sizeX(mm) sizeY(mm) sizeZ(mm)) [center(true|(false))]
mlx_cube() {
    local i
    local sizeX
    local sizeY
    local sizeZ
    local center
    
    # Box is centered on origin at creation
    echo "\
    <filter name=\"Box\">
        <Param name=\"size\" description=\"Scale factor\" value=\"1\" type=\"RichFloat\" tooltip=\"Scales the new mesh\"/>
    </filter>" >> "$ml_SF"
    
    # Defaults
    sizeX="1"
    sizeY="1"
    sizeZ="1"
    center="false"
    
    for i in "$@"
    do
    case $i in
        s=*|size=*)
            sizeX="${i#*=}"
            sizeY="${i#*=}"
            sizeZ="${i#*=}"
            shift # past argument=value
            ;;
        [xX]=*)
            sizeX="${i#*=}"
            shift # past argument=value
            ;;
        [yY]=*)
            sizeY="${i#*=}"
            shift # past argument=value
            ;;
        [zZ]=*)
            sizeZ="${i#*=}"
            shift # past argument=value
            ;;
        c=*|center=*)
            center="${i#*=}"
            shift # past argument=value
            ;;
        *)
            # unknown option
            ;;
    esac
    done
    
    mlx_scale x="$sizeX" y="$sizeY" z="$sizeZ"
    if [ "$center" != "true" ]; then # center=false
        mlx_translate x=$(bc <<< "scale=10;($sizeX/2)") y=$(bc <<< "scale=10;($sizeY/2)") z=$(bc <<< "scale=10;($sizeZ/2)") 
    fi
}

# Usage: height=(1) (radius=(1)|(radius1=(1) radius2=(1)))|(diameter=(2)|(diameter1=(2) diameter2=(2))) center=(false)
mlx_cylinder() {
# OpenSCAD cylinder:
#    h This is the height of the cylinder. Default value is 1.
#    r The radius of both top and bottom ends of the cylinder. Use this parameter if you want plain cylinder. Default value is 1.
#    r1 This is the radius of the cone on bottom end. Default value is 1.
#    r2 This is the radius of the cone on top end. Default value is 1.
#    d The diameter of both top and bottom ends of the cylinder. Use this parameter if you want plain cylinder. Default value is 1.
#    d1 This is the diameter of the cone on bottom end. Default value is 1.
#    d2 This is the diameter of the cone on top end. Default value is 1.
#    center If true will center the height of the cone/cylinder around the origin. Default is false, placing the base of the cylinder or r1 radius of cone at the origin.
   
    local i
    local height
    local radius1
    local radius2
    local center
    
    # Defaults
    height="1"
    radius1="1"
    radius2="1"
    center="false"
    if [ -z "$fn" ]; then fn="32"; fi
    
    for i in "$@"
    do
    case $i in
        h=*|height=*)
            height="${i#*=}"
            shift # past argument=value
            ;;
        r=*|radius=*)
            radius1="${i#*=}"
            radius2="$radius1"
            shift # past argument=value
            ;;
        r1=*|radius1=*)
            radius1="${i#*=}"
            shift # past argument=value
            ;;
        r2=*|radius2=*)
            radius2="${i#*=}"
            shift # past argument=value
            ;;
        d=*|diameter=*)
            radius1=$(bc <<< "scale=10;(${i#*=} / 2)")
            radius2="$radius1"
            shift # past argument=value
            ;;
        d1=*|diameter1=*)
            radius1=$(bc <<< "scale=10;(${i#*=} / 2)")
            shift # past argument=value
            ;;
        d2=*|diameter2=*)
            radius2=$(bc <<< "scale=10;(${i#*=} / 2)")
            shift # past argument=value
            ;;
        c=*|center=*)
            center="${i#*=}"
            shift # past argument=value
            ;;
        fn=*)
            fn="${i#*=}"
            shift # past argument=value
            ;;
        *)
            # unknown option
            ;;
    esac
    done
    
    # cone is created centered with Y up
    echo "\
    <filter name=\"Cone\">
        <Param name=\"r0\" description=\"Radius 1\" value=\"$radius1\" type=\"RichFloat\" tooltip=\"Radius of the bottom circumference\"/>
        <Param name=\"r1\" description=\"Radius 2\" value=\"$radius2\" type=\"RichFloat\" tooltip=\"Radius of the top circumference\"/>
        <Param name=\"h\" description=\"Height\" value=\"$height\" type=\"RichFloat\" tooltip=\"Height of the Cone\"/>
        <Param name=\"subdiv\" description=\"Side\" value=\"$fn\" type=\"RichInt\" tooltip=\"Number of sides of the polygonal approximation of the cone\"/>
    </filter>" >> "$ml_SF"
    if [ "$center" != "true" ]; then
        mlx_translate y=$(bc <<< "scale=10;($height/2)")
    fi
    if [ "$m_up" = "Z" ]; then
        mlx_rotate x=90 # rotate to Z up
    fi
}

# Usage: radius=(1) subdiv=(3)
mlx_sphere() {
    local i
    local radius
    local subdiv # Subdivision level; Number of the recursive subdivision of the surface. Default is 3 (a sphere approximation composed by 1280 faces). Admitted values are in the range 0 (an icosahedron) to 8 (a 1.3 MegaTris approximation of a sphere).
    # F=20*4^subdiv
    
    # Defaults
    radius="1"
    subdiv="3"
    #if [ -z "$fn" ]; then fn="32"; fi
    
    for i in "$@"
    do
    case $i in
        r=*|radius=*)
            radius="${i#*=}"
            shift # past argument=value
            ;;
        subdiv=*)
            subdiv="${i#*=}"
            shift # past argument=value
            ;;
        *)
            # unknown option
            ;;
    esac
    done
    
    echo "\
    <filter name=\"Sphere\">
        <Param name=\"radius\" description=\"Radius\" value=\"$radius\" type=\"RichFloat\" tooltip=\"Radius of the sphere\"/>
        <Param name=\"subdiv\" description=\"Subdiv. Level\" value=\"$subdiv\" type=\"RichInt\" tooltip=\"Number of the recursive subdivision of the surface. Default is 3 (a sphere approximation composed by 1280 faces).&lt;br>Admitted values are in the range 0 (an icosahedron) to 8 (a 1.3 MegaTris approximation of a sphere)\"/>
    </filter>" >> "$ml_SF"
}

# Usage: angle=(60) subdiv=(3)
mlx_sphere_cap() {
    local i
    local angle # Angle of the cone subtending the cap. It must be <180
    local subdiv # Subdivision level; Number of the recursive subdivision of the surface. Default is 3 (a sphere approximation composed by 1280 faces). Admitted values are in the range 0 (an icosahedron) to 8 (a 1.3 MegaTris approximation of a sphere).
    
    # Defaults
    angle="60"
    subdiv="3"
    
    for i in "$@"
    do
    case $i in
        a=*|angle=*)
            angle="${i#*=}"
            shift # past argument=value
            ;;
        subdiv=*)
            subdiv="${i#*=}"
            shift # past argument=value
            ;;
        *)
            # unknown option
            ;;
    esac
    done

    echo "\
    <filter name=\"Sphere Cap\">
        <Param name=\"angle\" description=\"Angle\" value=\"$angle\" type=\"RichFloat\" tooltip=\"Angle of the cone subtending the cap. It must be &lt; 180\"/>
        <Param name=\"subdiv\" description=\"Subdiv. Level\" value=\"$subdiv\" type=\"RichInt\" tooltip=\"Number of the recursive subdivision of the surface. Default is 3 (a sphere approximation composed by 1280 faces).&lt;br>Admitted values are in the range 0 (an icosahedron) to 8 (a 1.3 MegaTris approximation of a sphere)\"/>
    </filter>" >> "$ml_SF"
}

# Usage: (radius_h= radius_v= )|(ID= OD= ) fn_h= fn_v=
mlx_torus() {
    local i
    local radius_h # Radius of the whole horizontal ring of the torus
    local radius_v # Radius of the vertical section of the ring
    local ID # Alt; inner diameter of torus
    local OD # Alt; outer diameter of torus
    local fn_h # Subdivision step of the ring
    local fn_v # Number of sides of the polygonal approximation of the torus section
    
    #ID=2*(radius_h-radius_v)
    #OD=2*(radius_h+radius_v)
    
    # Defaults
    radius_h="3"
    radius_v="1"
    if [ -n "$fn" ]; then
        fn_h="$fn"
        fn_v="$fn"
    else
        fn_h="24"
        fn_v="12"
    fi

    for i in "$@"
    do
    case $i in
        rh=*|radius_h=*)
            radius_h="${i#*=}"
            shift # past argument=value
            ;;
        rv=*|radius_v=*)
            radius_v="${i#*=}"
            shift # past argument=value
            ;;
        ID=*)
            ID="${i#*=}"
            if [ -n "$OD" ]; then
                #radius_h=($ID+$OD)/4
                radius_h=$(bc <<< "scale=10;(($ID+$OD)/4)")
                #radius_v=$radius_h-$ID/2
                radius_v=$(bc <<< "scale=10;($radius_h-$ID/2)")
            fi            
            shift # past argument=value
            ;;
        OD=*)
            OD="${i#*=}"
            if [ -n "$ID" ]; then
                #radius_h=($ID+$OD)/4
                radius_h=$(bc <<< "scale=10;(($ID+$OD)/4)")
                #radius_v=$radius_h-$ID/2
                radius_v=$(bc <<< "scale=10;($radius_h-$ID/2)")
            fi 
            shift # past argument=value
            ;;
        fn_h=*)
            fn_h="${i#*=}"
            shift # past argument=value
            ;;
        fn_v=*)
            fn_v="${i#*=}"
            shift # past argument=value
            ;;
        *)
            # unknown option
            ;;
    esac
    done

    echo "\
    <filter name=\"Torus\">
        <Param name=\"hRadius\" description=\"Horizontal Radius\" value=\"$radius_h\" type=\"RichFloat\" tooltip=\"Radius of the whole horizontal ring of the torus\"/>
        <Param name=\"vRadius\" description=\"Vertical Radius\" value=\"$radius_v\" type=\"RichFloat\" tooltip=\"Radius of the vertical section of the ring\"/>
        <Param name=\"hSubdiv\" description=\"Horizontal Subdivision\" value=\"$fn_h\" type=\"RichInt\" tooltip=\"Subdivision step of the ring\"/>
        <Param name=\"vSubdiv\" description=\"Vertical Subdivision\" value=\"$fn_v\" type=\"RichInt\" tooltip=\"Number of sides of the polygonal approximation of the torus section\"/>
    </filter>" >> "$ml_SF"
}

# Usage: size=(1)|(X=(1) Y=(1)) center=(false)
# 2D square/plane/grid created on XY plane
mlx_square() { # 2D
    local i
    local sizeX
    local sizeY
    local center
    
    # Defaults
    sizeX="1"
    sizeY="1"
    center="false"
    
    # At minimum these must be 2 (start and end vertices); setting this
    #+to a higher value will create an evenly spaced grid.
    if [ -z "$mlx_square_num_V_X" ]; then mlx_square_num_V_X="2"; fi
    if [ -z "$mlx_square_num_V_Y" ]; then mlx_square_num_V_Y="2"; fi
    
    # "center" parameter does not actully center plane, not sure what it is doing. Set this to false, which places the plane in the -X,+Y quadrant.
    if [ -z "$mlx_square_center" ]; then mlx_square_center="false"; fi
    
    for i in "$@"
    do
    case $i in
        s=*|size=*)
            sizeX="${i#*=}"
            sizeY="${i#*=}"
            shift # past argument=value
            ;;
        [xX]=*)
            sizeX="${i#*=}"
            shift # past argument=value
            ;;
        [yY]=*)
            sizeY="${i#*=}"
            shift # past argument=value
            ;;
        c=*|center=*)
            center="${i#*=}"
            shift # past argument=value
            ;;
        *)
            # unknown option
            ;;
    esac
    done
    
    echo "\
    <filter name=\"Grid Generator\">
        <Param name=\"numVertX\" description=\"num vertices on x\" value=\"$mlx_square_num_V_X\" type=\"RichInt\" tooltip=\"number of vertices on x. it must be positive\"/>
        <Param name=\"numVertY\" description=\"num vertices on y\" value=\"$mlx_square_num_V_Y\" type=\"RichInt\" tooltip=\"number of vertices on y. it must be positive\"/>
        <Param name=\"absScaleX\" description=\"x scale\" value=\"$sizeX\" type=\"RichFloat\" tooltip=\"absolute scale on x (float)\"/>
        <Param name=\"absScaleY\" description=\"y scale\" value=\"$sizeY\" type=\"RichFloat\" tooltip=\"absolute scale on y (float)\"/>
        <Param name=\"center\" description=\"centered on origin\" value=\"$mlx_square_center\" type=\"RichBool\" tooltip=\"center grid generated by filter on origin.&lt;br>Grid is first generated and than moved into origin (using muparser lib to perform fast calc on every vertex)\"/>
    </filter>" >> "$ml_SF"
    
    if [ "$center" = "true" ]; then #last positional parameter, center
        mlx_translate x=$(bc <<< "scale=10;($sizeX/2)") y=$(bc <<< "scale=10;(-$sizeY/2)")        
    else
        mlx_translate x="$sizeX"
    fi
}

# Usage: (radius=(1)|(radius1=(1) radius2=(0)))|(diameter=(2)|(diameter1=(2) diameter2=(0)))
#2D annulus
mlx_circle() { #2D
    local i
    local radius1 # Outer radius of the circle
    local radius2 # Inner radius of the circle (if non-zero it creates an annulus)

    # Defaults
    radius1="1"
    radius2="0" #"0.5"
    if [ -z "$fn" ]; then fn="32"; fi
    
    for i in "$@"
    do
    case $i in
        r=*|radius=*|r1=*|radius1=*)
            radius1="${i#*=}"
            shift # past argument=value
            ;;
        r2=*|radius2=*)
            radius2="${i#*=}"
            shift # past argument=value
            ;;
        d=*|diameter=*|d1=*|diameter1=*)
            radius1=$(bc <<< "scale=10;(${i#*=} / 2)")
            shift # past argument=value
            ;;
        d2=*|diameter2=*)
            radius2=$(bc <<< "scale=10;(${i#*=} / 2)")
            shift # past argument=value
            ;;
        fn=*)
            fn="${i#*=}"
            shift # past argument=value
            ;;
        *)
            # unknown option
            ;;
    esac
    done
    
    # Annulus is created centered on the XY plane
    
    echo "\
    <filter name=\"Annulus\">
        <Param name=\"internalRadius\" description=\"Internal Radius\"value=\"$radius2\" type=\"RichFloat\"  tooltip=\"Internal Radius of the annulus\"/>
        <Param name=\"externalRadius\" description=\"External Radius\" value=\"$radius1\" type=\"RichFloat\" tooltip=\"External Radius of the annulus\"/>
        <Param name=\"sides\" description=\"Sides\" value=\"$fn\" type=\"RichInt\" tooltip=\"Number of the sides of the poligonal approximation of the annulus\"/>
    </filter>" >> "$ml_SF"
}

### End Create ###


