#!/bin/bash
#mlx_scratch.bsh
#license: public domain
# scratch script for using mlx functions

#set -x
scriptpath="$(cd "$(dirname "$0")"; pwd -P)"
verbosity=6
delete_TEMP3DP_files="true"

#cd "${scriptpath}/../test_models"

# switches:
# if [ 1 ]; then # ON, any number or string is true
# if [ ]; then # OFF, NULL is false

if [ 1 ]; then
    if [ -z "$1" ]; then 
        set "${scriptpath}/../test_models/PLANE.obj" # Sets 1st positional parameter, use absolute path 
    fi
fi

. ${scriptpath}/3DP-main.bsh

#cd "${scriptpath}/../test_models/"

#do_metadata "$fbase"
#do_subfiles "$fbase"
#do_measure_size "$fbase"

if [  ]; then
    ml_IF="$fbase"
    #ml_OF="${fpref}-create${meta}.stl"
    ml_OF="test.obj"
    ml_SF="TEMP3DP_mlx_scratch.mlx"
    ml_LF="" # "TEMP3DP_meshlablog.txt"  

    mlx_begin

    # mlx_measure_geometry #>=1.3.4 # Compute Geometric Measures
    # mlx_measure_topology #>=1.3.4 # Compute Topological Measures
    # mlx_del_small_parts # Delete Small Components # stl needs vertices merged
    # mlx_rotate x=90 # Usage: rotAxis angle
    # mlx_translate x=0 y=0 z=0 # Usage: transX transY transZ
    # mlx_scale scale=1 # Usage: scale | scaleX scaleY scaleZ
    # mlx_section y=0 surface=true #>=1.3.4 # Usage: planeAxis planeOffset (line | surface)
    # mlx_simplify faces=10000 # Usage: TargetFaceNum # stl needs vertices merged
    # mlx_offset voxel=3 delta=3 #
    # mlx_offset voxel=2 delta=3 # Usage: cellsize offset
    # mlx_subdivide 1 # Usage: Iterations
    # mlx_smooth 1 # Usage: Iterations
    # mlx_measure_topology
    
    if [  ]; then
        #mlx_section z=0 surface=false
        #mlx_section custom=0 customaxis=,5, surface=true planeref=1
        mlx_rotate x=65 y=30 customaxis=1,2 custom=20 customCenter=7,,9 center=custom customaxis=4,,6 custom=25 customaxis=,, custom=35
    fi
    
    if [  ]; then
        #mlx_offset voxel=1 delta=0.1
        mlx_cube
        mlx_scale scale=8192
    fi

    if [  ]; then
        mlx_del_small_parts
        mlx_measure_topology
    fi

    if [  ]; then
        mlx_measure_geometry
        mlx_measure_topology
    fi
    
    if [  ]; then
        mlx_del_layer
        #mlx_cube s=10
        #mlx_square 10 10 true
        #mlx_cylinder h=5 r1=1 r2=2 fn=100

    fi
    
    mlx_end

    #set -x
    run_meshlab
    #meshlabserver -o "$ml_OF" -s "$ml_SF"
    return_code=$?
fi

# TODO: test out mlp files; can you output multiple files?

# Create a target!
if [  ]; then
    fn=50
    ml_IF="$fbase"
    ml_SF="TEMP3DP_target.mlx"
    ml_OF="target.obj"
    mlx_begin
    mlx_del_layer
    mlx_circle r=1
    mlx_per_V_color_func r=255
    mlx_circle r1=2 r2=1
    mlx_circle r1=3 r2=2
    mlx_per_V_color_func r=255
    mlx_circle r1=4 r2=3
    mlx_circle r1=5 r2=4
    mlx_per_V_color_func r=255
    mlx_flatten_layers
    mlx_end
    
    #TODO: try this without an input file
    #meshlabserver -o "$ml_OF" -m vn vc  -s "$ml_SF"
    meshlabserver -i "$ml_IF" -o "$ml_OF" -m vn vc  -s "$ml_SF"
    return_code=$?
    if [ $return_code -ne 0 ]; then
        pause "Uh oh, looks like there's an error. Hit any key to keep going anyway ... "
    fi
fi

if [ 1 ]; then

do_half_bust_FFF "$fbase"

fi

# load file
if [  ]; then
    i=0
    j=0
    while read type x y z; do
        if [ "$type" = "v" ]; then
            vertices[$i]=$x,$y,$z #"\[$x,$y,$z\]"
            ((i++))
            #echo $i
        fi
        if [ "$type" = "l" ]; then
            line_segments[$j]=$x,$y #"\[$x,$y,$z\]"
            ((j++))
            #echo $i
        fi        
    done < test_section.obj
    
    # extract head and tail vertex numbers
    #echo $(echo ${line_segments[0]} | cut -d"," -f1)
    head=${line_segments[0]%,*}
    tail=${line_segments[0]#*,}
    echo head="$head"
    echo tail="$tail"
    
    # read invividual vertex into array
    OIFS="$IFS"; IFS=,; read -a vertex1 <<< ${vertices[0]}; IFS="$OIFS"
    echo "vertex 1 ="${vertex1[@]}
    
    #line_num=0
    #i=0
    #line_1[0]=${line_segments[0]%,*}
    #line_1[1]=${line_segments[0]#*,}
    #for a in ${line_segments[@]}; do
    
    #reverse array and try again!
    
    #printf "%s\n" "${vertices[@]}" > vertices.txt
    #printf "%s\n" "${line_segments[@]}" > line_segments.txt    
    
    # OIFS="$IFS"; IFS=$'\n'; array=($(<file)); IFS="$OIFS"
    # Copy $IFS, set $IFS to newline, slurp file into array and reset $IFS back again.
    # OIFS="$IFS"; IFS=,; echo "${my_path[*]}"; IFS="$OIFS"
    # OIFS="$IFS"; IFS=,; my_path_scad="[${my_path[*]}]"; IFS="$OIFS"
    # echo "$my_path_scad"

fi

# load sorted xyz
if [  ]; then
    j=1
    for a in polyline*.xyz; do
        # There's got to be a better way to do this without multidimensional arrays
        case $j in
            1)
                i=0
                polylinelength1=0
                while read x y z; do
                    polyline1[$i]="[$x,$y,$z]" # for openscad
                    # TODO: measure length of polyline while we read it
                    if [ $i -gt 0 ]; then
                        polylinelength1=$(bc <<< "scale=10;(sqrt( ($x-$x0)^2+($y-$y0)^2+($z-$z0)^2)+$polylinelength1)")
                    fi
                    x0=$x
                    y0=$y
                    z0=$z
                    ((i++))
                done < "$a"
                ((j++))
                ;;
            2)
                i=0
                polylinelength1=0
                while read x y z; do
                    polyline1[$i]="[$x,$z]" # for openscad
                    #if [ $i -gt 0 ]; then
                        #polylinelength1==$(bc <<< "($sizeX/2)")
                    #fi
                    # TODO: measure length of polyline while we read it
                    ((i++))
                done < "$a"
                ((j++))
                ;;
            3)
                i=0
                polylinelength1=0
                while read x y z; do
                    polyline1[$i]="[$x,$z]" # for openscad
                    #if [ $i -gt 0 ]; then
                        #polylinelength1==$(bc <<< "($sizeX/2)")
                    #fi
                    # TODO: measure length of polyline while we read it
                    ((i++))
                done < "$a"
                ((j++))
                ;;
            4)
                i=0
                polylinelength1=0
                while read x y z; do
                    polyline1[$i]="[$x,$z]" # for openscad
                    #if [ $i -gt 0 ]; then
                        #polylinelength1==$(bc <<< "($sizeX/2)")
                    #fi
                    # TODO: measure length of polyline while we read it
                    ((i++))
                done < "$a"
                ((j++))
                ;;
            5)
                i=0
                polylinelength1=0
                while read x y z; do
                    polyline1[$i]="[$x,$z]" # for openscad
                    #if [ $i -gt 0 ]; then
                        #polylinelength1==$(bc <<< "($sizeX/2)")
                    #fi
                    # TODO: measure length of polyline while we read it
                    ((i++))
                done < "$a"
                ((j++))
                ;;
            *)
                # too many
                ;;
        esac
        #declare -A "polyline$j"
        # ${a%.*} # strip extension
        #arrayname="polyline"

        #eval array=\( \${${arrayname}[@]} \)
    done
    
    OIFS="$IFS"; IFS=,; path_scad="[${polyline[*]}]"; IFS="$OIFS"
    echo "$path_scad" > path_scad.txt
    
    # TODO:
    
    #line_num=0
    #i=0
    #line_1[0]=${line_segments[0]%,*}
    #line_1[1]=${line_segments[0]#*,}
    #for a in ${line_segments[@]}; do
    
    #reverse array and try again!
    
    #printf "%s\n" "${vertices[@]}" > vertices.txt
    #printf "%s\n" "${line_segments[@]}" > line_segments.txt    
    
    # OIFS="$IFS"; IFS=$'\n'; array=($(<file)); IFS="$OIFS"
    # Copy $IFS, set $IFS to newline, slurp file into array and reset $IFS back again.
    # OIFS="$IFS"; IFS=,; echo "${my_path[*]}"; IFS="$OIFS"
    # OIFS="$IFS"; IFS=,; my_path_scad="[${my_path[*]}]"; IFS="$OIFS"
    # echo "$my_path_scad"

fi


if [  ]; then
    echo ; echo -n "Drop a file here, what happens?"
    read file
    echo "$file"
fi

if [  ]; then
    do_measure_dimension   y=2 $1 z=5
fi

##do_measure_dimension "$fbase" x=-.1938705000 y=24.4973510000

pause
